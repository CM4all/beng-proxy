// SPDX-License-Identifier: BSD-2-Clause
// Copyright CM4all GmbH
// author: Max Kellermann <mk@cm4all.com>

#include "TranslationCache.hxx"
#include "http/IncomingRequest.hxx"
#include "translation/InvalidateParser.hxx"
#include "translation/Response.hxx"
#include "translation/Protocol.hxx"

#include <memory>

using std::string_view_literals::operator""sv;

LbTranslationCache::Vary::Vary(const TranslateResponse &response) noexcept
	:host(response.VaryContains(TranslationCommand::HOST)),
	 listener_tag(response.VaryContains(TranslationCommand::LISTENER_TAG)) {}

[[gnu::pure]]
static std::string_view
WithVary(const char *value, bool vary) noexcept
{
	if (!vary)
		return {};

	if (value == nullptr)
		return ""sv;

	return value;
}

[[gnu::pure]]
static constexpr size_t
CalculateKeyIteratorBufferSize(std::string_view host,
			       std::string_view listener_tag) noexcept
{
	/* the ones are: underscore, separator, underscore, null terminator */
	return 1 + host.size() + 1 + 1 + listener_tag.size() + 1;
}

/**
 * A helper class which generates key permutations for lookup.
 */
class LbTranslationCacheKeyIterator {
	static constexpr unsigned HOST = 0x1;
	static constexpr unsigned LISTENER_TAG = 0x2;

	const std::string_view host, listener_tag;

	std::unique_ptr<char[]> buffer;

	unsigned last = 4;

public:
	LbTranslationCacheKeyIterator(LbTranslationCache::Vary vary,
				      const IncomingHttpRequest &request,
				      const char *_listener_tag) noexcept
		:host(vary.host
		      ? WithVary(request.headers.Get("host"), vary.host)
		      : std::string_view{}),
		 listener_tag(WithVary(_listener_tag, vary.listener_tag)),
		 buffer(new char[CalculateKeyIteratorBufferSize(host, listener_tag)]) {}

	/**
	 * Generates the next key.  Call this until it returns nullptr.
	 */
	const char *NextKey() noexcept {
		if (last <= 0)
			return nullptr;

		last = NextIndex(last);
		assert(last < 4);
		return MakeKey(last);
	}

	/**
	 * Generates a key for storing into the cache.
	 */
	const char *FullKey() const noexcept {
		return MakeKey(((host.data() != nullptr) * HOST) |
			       ((listener_tag.data() != nullptr) * LISTENER_TAG));
	}

private:
	static constexpr bool HasHost(unsigned i) noexcept {
		return i & HOST;
	}

	static constexpr bool HasListenerTag(unsigned i) noexcept {
		return i & LISTENER_TAG;
	}

	bool IsInactive(int i) const noexcept {
		assert(i < 4);

		return (HasHost(i) && host.data() == nullptr) ||
			(HasListenerTag(i) && listener_tag.data() == nullptr);
	}

	unsigned NextIndex(unsigned i) const noexcept {
		assert(i <= 4);

		for (--i; IsInactive(i); --i) {}
		return i;
	}

	const char *MakeKey(unsigned i) const noexcept {
		assert(i < 4);

		char *result = buffer.get(), *p = result;

		if (HasHost(i)) {
			/* the underscore is just here to make a difference
			   between "wildcard" (nothing) and "empty value"
			   (underscore) */
			*p++ = '_';
			p = std::copy(host.begin(), host.end(), p);
		}

		*p++ = '|';

		if (HasListenerTag(i)) {
			/* see above for the underscore explanation */
			*p++ = '_';
			p = std::copy(listener_tag.begin(), listener_tag.end(), p);
		}

		*p = 0;
		return result;
	}
};

LbTranslationCache::Item::Item(const TranslateResponse &response) noexcept
	:status(response.status),
	 https_only(response.https_only)
{
	if (response.redirect != nullptr)
		redirect = response.redirect;

	if (response.message != nullptr)
		message = response.message;

	if (response.pool != nullptr)
		pool = response.pool;

	if (response.canonical_host != nullptr)
		canonical_host = response.canonical_host;

	if (response.site != nullptr)
		site = response.site;
}

size_t
LbTranslationCache::GetAllocatedMemory() const noexcept
{
	size_t result = 0;

	cache.ForEach([&result](const std::string &key, const Item &item){
		result += key.length() + item.GetAllocatedMemory();
	});

	return result;
}

void
LbTranslationCache::Clear() noexcept
{
	cache.Clear();
	seen_vary.Clear();
}

static bool
KeyVaryMatch(std::string_view item, const char *request) noexcept
{
	if (request == nullptr)
		return true;

	size_t request_size = strlen(request);
	return item.size() == 1 + request_size &&
		item.front() == '_' &&
		memcmp(item.data() + 1, request, request_size) == 0;
}

/**
 * Match a cache key generated by
 * LbTranslationCacheKeyIterator::MakeKey() against VARY settings in a
 * #TranslateRequest (for #CONTROL_TCACHE_INVALIDATE).
 */
static bool
MatchKey(const char *key, const TranslateRequest &request) noexcept
{
	const char *separator = strchr(key, '|');
	assert(separator != nullptr);

	return KeyVaryMatch({key, separator}, request.host) &&
		KeyVaryMatch(separator + 1, request.listener_tag);
}

static bool
MatchInvalidate(const std::string &item, const char *vary) noexcept
{
	return vary == nullptr || item == vary;
}

static bool
MatchItem(const LbTranslationCache::Item &item,
	  const TranslationInvalidateRequest &request) noexcept
{
	return MatchInvalidate(item.site, request.site);
}

void
LbTranslationCache::Invalidate(const TranslationInvalidateRequest &request) noexcept
{
	if ((request.host != nullptr && !seen_vary.host) ||
	    (request.listener_tag != nullptr && !seen_vary.listener_tag))
		return;

	cache.RemoveIf([&request](const std::string &key, const Item &item){
		return MatchKey(key.c_str(), request) && MatchItem(item, request);
	});
}

const LbTranslationCache::Item *
LbTranslationCache::Get(const IncomingHttpRequest &request,
			const char *listener_tag) noexcept
{
	LbTranslationCacheKeyIterator ki(seen_vary, request, listener_tag);

	while (const char *key = ki.NextKey()) {
		const LbTranslationCache::Item *item = cache.Get(std::string_view{key});
		if (item != nullptr) {
			logger(4, "hit '", key, "'");
			return item;
		}
	}

	logger(5, "miss");
	return nullptr;
}

void
LbTranslationCache::Put(const IncomingHttpRequest &request,
			const char *listener_tag,
			const TranslateResponse &response) noexcept
{
	if (response.max_age == std::chrono::seconds::zero())
		/* not cacheable */
		return;

	const Vary vary(response);

	if (!vary && !cache.IsEmpty()) {
		logger(4, "VARY disappeared, clearing cache");
		Clear();
	}

	seen_vary |= vary;

	LbTranslationCacheKeyIterator ki(vary, request, listener_tag);
	const char *key = ki.FullKey();

	logger(4, "store '", key, "'");

	cache.PutOrReplace(key, Item(response));
}
