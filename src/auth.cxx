/*
 * #TRANSLATE_AUTH implementation.
 *
 * author: Max Kellermann <mk@cm4all.com>
 */

#include "request.hxx"
#include "bp_connection.hxx"
#include "bp_instance.hxx"
#include "tcache.hxx"
#include "http_server.hxx"
#include "pool.hxx"
#include "pbuffer.hxx"
#include "translate_client.hxx"
#include "translate_quark.hxx"
#include "load_file.hxx"
#include "http_quark.h"
#include "expiry.h"

#include <daemon/log.h>

static void
auth_translate_response(TranslateResponse *response, void *ctx)
{
    auto &request = *(struct request *)ctx;

    auto *session = request.ApplyTranslateSession(*response);
    bool is_authenticated = false;
    if (session != nullptr) {
        is_authenticated = session->user != nullptr;
        session_put(session);
    }

    if (request.CheckHandleRedirectBounceStatus(*response))
        return;

    if (!is_authenticated) {
        /* for some reason, the translation server did not send
           REDIRECT/BOUNCE/STATUS, but we still don't have a user -
           this should not happen; bail out, don't dare to accept the
           client */
        response_dispatch_message(request, HTTP_STATUS_FORBIDDEN,
                                  "Forbidden");
        return;
    }

    request.translate.user_modified = response->user != nullptr;

    request.OnTranslateResponseAfterAuth(*request.translate.previous);
}

static void
auth_translate_error(GError *error, void *ctx)
{
    auto &request = *(struct request *)ctx;

    daemon_log(1, "translation error on '%s': %s\n",
               request.request->uri, error->message);

    /* pretend this error was generated by the translation client, so
       the HTTP client sees a 500 and not a 404 (if the translation
       server is not running) */
    if (error->domain != translate_quark() &&
        error->domain != http_response_quark()) {
        error->domain = translate_quark();
        error->code = 0;
    }

    response_dispatch_error(request, error);
    g_error_free(error);
}

static constexpr TranslateHandler auth_translate_handler = {
    .response = auth_translate_response,
    .error = auth_translate_error,
};

void
request::HandleAuth(const TranslateResponse &response)
{
    auto &pool = *request->pool;

    assert(response.HasAuth());

    auto auth = response.auth;
    if (auth.IsNull()) {
        /* load #TRANSLATE_AUTH_FILE */
        assert(response.auth_file != nullptr);

        GError *error = nullptr;
        auth = LoadFile(pool, response.auth_file, 64, &error);
        if (auth.IsNull()) {
            response_dispatch_error(*this, error);
            g_error_free(error);
            return;
        }
    } else {
        assert(response.auth_file == nullptr);
    }

    if (!response.append_auth.IsNull()) {
        assert(!auth.IsNull());

        auth = LazyCatBuffer(pool, auth, response.append_auth);
    }

    /* we need to validate the session realm early */
    ApplyTranslateRealm(response);

    auto *session = request_get_session(*this);
    if (session != nullptr) {
        bool is_authenticated = session->user != nullptr &&
            (session->user_expires == 0 ||
             !is_expired(session->user_expires));
        session_put(session);
        if (is_authenticated) {
            /* already authenticated; we can skip the AUTH request */
            OnTranslateResponseAfterAuth(response);
            return;
        }
    }

    auto t = NewFromPool<TranslateRequest>(pool);
    t->Clear();
    t->auth = auth;
    t->uri = request->uri;
    t->host = translate.request.host;
    t->session = translate.request.session;

    translate.previous = &response;

    translate_cache(pool,
                    *connection->instance->translate_cache,
                    *t,
                    auth_translate_handler, this,
                    async_ref);
}

