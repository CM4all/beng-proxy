\documentclass[a4paper,12pt]{article}
\usepackage[pdftex,bookmarks]{hyperref}
\usepackage{longtable}

\setlength\LTleft{0pt}
\setlength\LTright{0pt}

\begin{document}
\title{CM4all Beng}
\author{Max Kellermann}

\maketitle

\begin{abstract}
Beng proxy is an HTTP server including an HTTP proxy and a
minimalistic template processor.  Its goal is to dynamically aggregate
a web site from a number of sources (widgets).
\end{abstract}

\setcounter{tocdepth}{2}
\tableofcontents
\newpage

\section{Features}

Beng-proxy delivers resources via HTTP.  In the most simple form, it
it provides a resource in pass-through mode, acting as an HTTP proxy.

It caches resources if possible.

It can filter any resources by POSTing it to a HTTP server,
e.g. to apply XSLT to a XML resource.

On HTML resources, it can apply a simple template language.  This
language provides commands to insert another HTML page, which is
called \textbf{Widget}.

\subsection{Widgets}

A \textbf{Widget} is an object which can be inserted into a web site.
It is rendered by a Widget server into HTML.

We do not assume that we can trust the widget server.  As a
consequence, we have to ensure that a malicious widget server cannot
compromise the security of \emph{beng-proxy}, the client or even other
widget servers.

There is a global registry for well-known preconfigured widgets.  The
user can also choose to run his own (non-registered) widget server.
In fact, any public HTTP server should be able to act as a widget
server.


\subsection{Cookies}

\emph{beng-proxy} can be accessed with cookies switched off.  It includes a
full-featured session management and provides cookies for the widget
servers.

\emph{beng-proxy} maintains the client's session id in either a cookie
or as part of the URI.  In its local session storage, it holds all
cookies which were created by the widget servers.  This way, the
client gets to see only the one session id, disregarding how much
session information may be managed by \emph{beng-proxy}.


\subsection{JavaScript}

Since all widgets are put together into a single HTML page, all of the
JavaScript runs in the same security context.  That will open the door
for malicious widget servers, which are now able to take over the full
web site, including all other widgets.  For that reason, only
well-known and trusted widget servers should be allowed to be inlined.
All other widget must be embedded in an IFRAME in another domain.


\subsection{Forms}

\emph{beng-proxy} itself does not use the query string and the request
body.  Both is forwarded to the ``focused'' widget.  See \ref{rewrite}
for information on widget focus.


\section{Installation}

\emph{beng-proxy} requires a Debian Lenny operating system: Linux
kernel 2.6.26 and glibc 2.7.  For compiling the source code, you need
a C99 compiler, e.g. gcc 4.3.

Install the package \texttt{cm4all-beng-proxy} and the translation
server of your choice.  Edit the file
\texttt{/etc/default/cm4all-beng-proxy}, and set the port number and
the path of the translation server socket.  Set the \texttt{WORKERS}
variable to the number of CPU cores in that server (or up to twice as
large).  Finally, restart \emph{beng-proxy}:

\begin{verbatim*}
/etc/init.d/cm4all-beng-proxy restart
\end{verbatim*}

\subsection{Configuration options}

The command line argument \texttt{--set} allows you to tweak some
settings:

\begin{longtable}{|l|p{8cm}|}
\hline

\texttt{max\_connections} & The maximum number of incoming HTTP
connections. \\
\hline

\texttt{tcp\_stock\_limit} & The maximum number of outgoing TCP
connections per remote host.  0 means unlimited, which has shown to be
a bad choice, because many servers do not scale well. \\

\hline

\texttt{http\_cache\_size} & The maxmimum amount of memory used by the
HTTP cache.  Set to 0 to disable the HTTP cache. \\

\hline

\texttt{filter\_cache\_size} & The maxmimum amount of memory used by
the filter cache.  Set to 0 to disable the filter cache. \\

\hline

\texttt{translate\_cache\_size} & The maxmimum number of cached
translation server responses.  Set to 0 to disable the translate
cache. \\

\hline

\texttt{stopwatch} & Set to \texttt{yes} to enable the stopwatch.  See
\ref{stopwatch} for details. \\

\hline
\end{longtable}

\label{memcached}
You may specify \texttt{--memcached-server} followed by a server name.
This disables the local heap cache, and allows \emph{beng-proxy} to
share the cache with several (distributed) workers.  With the local
heap cache disabled, all of its configuration options are ignored.

\label{bulldog}
With \texttt{--bulldog-path}, \emph{beng-proxy} reads status
information on servers it contacts from the Bulldog-Tyke data
directory.

\section{Running}

\subsection{Signals}

On \texttt{SIGHUP}, the log file is reopened and all caches are
flushed.


\section{Tuning}

\subsection{The Stopwatch}
\label{stopwatch}

The stopwatch measures the latency of external resources (e.g. remote
HTTP servers, CGI and pipe programs).  It is only available in the
debug build (compile-time option \texttt{--enable-stopwatch}).

Example output:

\begin{verbatim*}
stopwatch[172.30.0.23:80 /test.py]: request=5ms headers=85ms
end=88ms (beng-proxy=1+2ms)
\end{verbatim*}

Here, the HTTP request to \texttt{172.30.0.23:80} was sent within 5
milliseconds.  After 85 milliseconds, the response headers were
received, and after 3 more milliseconds, the response body was
received.  All of these refer to wallclock time, relative to the start
of the operation.  Each client library may have its own set of
breakpoints.

During this HTTP request, \emph{beng-proxy} consumed 3 milliseconds or
raw CPU time (not wallclock time): 1 millisecond in user space, and 2
milliseconds for the kernel.

\section{Resources}

\emph{beng-proxy} delivers resources to its HTTP clients.  It obtains
these resources from several sources.

\subsection{Static files}
\label{static}

Local ``regular'' files can be served by \emph{beng-proxy}.  This is
the fastest mode, and should be preferred, if possible.  The
\texttt{Range} request header is supported (bytes only).

\subsubsection{Content type}

\label{xattr}

In contrast to most other web servers, \emph{beng-proxy} does not use
the file name to determine the \texttt{Content-Type} response header.
Instead, it reads this information from \textit{extended attributes}.
The programs \texttt{getfattr} and \texttt{setfattr} (Debian package
\texttt{attr}) enable you to read and write attributes:

\begin{verbatim*}
setfattr -n user.Content-Type -v "text/html; charset=utf8" \
/var/www/index.html
\end{verbatim*}

Some file systems need explicit support for extended attributes (mount
option \texttt{user\_xattr}).  On
XFS, extended attributes are always enabled.

\subsubsection{ETag}

The \texttt{ETag} response header is read from the \texttt{user.ETag}
extended attribute (see \ref{xattr}).  If none is present, it is
generated from the inode number and the modification time.  The request
headers \texttt{If-Match} and \texttt{If-None-Match} are supported.

\subsubsection{Expires}

If the \texttt{user.MaxAge} attribute exists, it is parsed as a
decimal integer.  The \texttt{Expires} response header is then
generated by adding this number of seconds to the current time stamp.
The maximum accepted value for \texttt{user.MaxAge} is one year.

\subsubsection{Directory index}

For security (by obscurity) reasons, \emph{beng-proxy} has no code for
generating directory listings.

\subsection{Delegates}
\label{delegate}

A ``delegate'' is a helper program which opens a local file and passes
the file descriptor to \emph{beng-proxy}.  The major reason for using
a delegate is to take advantage of the kernel's validation: the
delegate program may run with different privileges, different resource
limits or in a chroot/vserver.

The delegate reads requests on standard input.  The protocol is
similar to the translation protocol.  The file descriptor is sent to
\emph{beng-proxy} in a \texttt{SOL\_SOCKET} ancillary message.

If the \texttt{DELEGATE} translation packet was followed by a
\texttt{DOCUMENT\_ROOT} packet, then all helper processes are grouped
by their document root, and text \texttt{DOCUMENT\_ROOT} environment
variable is set.  In this case, it is possible to run the delegate
helper inside JailCGI by specifying the \texttt{JAILCGI} packet.

\subsection{HTTP proxying}
\label{http}

\emph{beng-proxy} implements an HTTP client, which allows it to act as
a reverse HTTP proxy server.  You should never make \emph{beng-proxy}
connect to itself.

\subsubsection{Caching}

Responses from the remote servers are cached, if possible.  To allow
proper caching, the remote server must set the response headers
\texttt{Last-Modified}, \texttt{Expires} and \texttt{ETag} properly.
Additionally, they should understand the according request headers
\texttt{If-Modified-Since} and \texttt{If-Unmodified-Since},
\texttt{If-Match}, \texttt{If-None-Match}.

The cache is local to a \emph{beng-proxy} worker.  To share the cache
across workers and even across hosts, you may use a memcached server
(see \ref{memcached}).

\subsubsection{Connection pooling}

\emph{beng-proxy} attempts to use HTTP 1.1 keep-alive, to be able to
reuse existing connections to a remote server.

\subsubsection{Load balancing, failover}

For a remote URL, more than one server may be specified.
\texttt{beng-proxy} tries to use all of these equally.  If one server
fails on the socket level, \texttt{beng-proxy} ignores it for a short
amount of time.

Advanced users may take advantage of Bulldog-Tyke data, by passing
with the option \texttt{--bulldog-path} (see \ref{bulldog}).

\subsection{AJP v1.3}
\label{ajp}

Similar to HTTP proxying, \emph{beng-proxy} can act as a HTTP-to-AJP
bridge.

The AJP client also supports connection pooling and load balancing.

\subsection{CGI and FastCGI}
\label{cgi}

Local CGI programs may be used to generate dynamic resources.
\emph{beng-proxy} supports running these with JailCGI.

The FastCGI implementation is under development, and is not usable
yet.

\subsection{Pipe filters}
\label{pipe}

A pipe is a program which filters a resource by reading it from
standard input, and writing the result to standard output.  This
option cannot be used to generate a resource, but only for resource
filters.  The same can be achieved with CGI, but pipes are simpler to
implement, because they do not need to bother with HTTP status code
and headers.


\section{Translation}

\emph{beng-proxy} knows two ways to locate the resource a request URI
points to:

\begin{itemize}
\item via an external translation server
\item static translation
\end{itemize}

The latter is only for debugging.

\subsection{Static translation}

The URI path is appended to the document root (\texttt{/var/www} by
default).

\subsubsection{Directory index}

For security (by obscurity) reasons, \emph{beng-proxy} has no code for
generating directory listings.  If the request has a trailing slash,
\emph{beng-proxy} looks for a file named \texttt{index} or
\texttt{index.html} and serves it.  Without the trailing slash,
\emph{beng-proxy} refuses to handle the request.


\subsection{Translation server}

The translation server should be the default on production servers.
It is a daemon on the same physical machine which does all the
translation work for us.  \emph{beng-proxy} connects to a Unix socket
to contact this translation server.

A request may consist of several micro commands.  The request is
initialized with the \texttt{BEGIN} command, which is followed by any
number of commands which provide parameters.  After all parameters
have been transferred, the client sends the \texttt{END} command,
and waits for the server's response.

The client can send any number of requests over the socket until one
side closes the connection.

\subsubsection{Example conversation}

\begin{itemize}
\item client sends \texttt{BEGIN}
\item client sends \texttt{REMOTE\_HOST} ``192.168.1.77''
\item client sends \texttt{HOST} ``www.example.com''
\item client sends \texttt{URI} ``/foo/index.html''
\item client sends \texttt{END}
\item server sends \texttt{BEGIN}
\item server sends \texttt{PATH} ``/var/www/foo/index.html''
\item server sends \texttt{CONTENT\_TYPE} ``text/html; charset=utf8''
\item server sends \texttt{PROCESS}
\item server sends \texttt{END}
\end{itemize}

\subsubsection{Command packets}

The protocol is binary and uses host byte order.  A command packet may
look like this in pseudo C:

\begin{verbatim}
struct beng_proxy_translate_packet {
    uint16_t length;
    uint16_t command;
    char payload[length];
};
\end{verbatim}

The \texttt{length} only refers to the payload.  The maximum supported
payload size is 65535 bytes.

Most parameters are ASCII strings; in this case, the payload contains
just the raw string, without terminating zero.

\subsubsection{Request}

\begin{longtable}{|l|p{10cm}|}
\hline

\texttt{LOCAL\_ADDRESS} & The local socket address the request was
received on.  The payload is a \texttt{struct sockaddr}. \\

\hline
\texttt{REMOTE\_HOST} & the client's IP address or host name \\
\hline
\texttt{HOST} & the \texttt{Host} HTTP request header \\
\hline
\texttt{URI} & the raw URI from the HTTP request (without the query
string) \\
\hline

\texttt{QUERY\_STRING} & the query string from request URI, without
the question mark \\

\hline
\texttt{SESSION} & a session identifier generated by the translation
server, see section \ref{sessions} \\
\hline
\texttt{PARAM} & a parameter passed by the browser \\

\hline

\texttt{USER\_AGENT} & the \texttt{User-Agent} request header sent by
the client (not in the widget registry) \\

\hline

\texttt{LANGUAGE} & the \texttt{Accept-Language} request header sent
by the client (not in the widget registry) \\

\hline

\end{longtable}

\subsubsection{Response}

\begin{longtable}{|l|p{8cm}|}

\hline

\texttt{URI} & the ``real'' raw URI from the HTTP request (without the
query string); this is used to override the URI, e.g. when
\emph{beng-proxy} is behind another proxy which modifies the URI \\

\hline

\texttt{HOST} & the host name for generating absolute URLs; default is
the \texttt{Host} HTTP request header \\

\hline

\texttt{SCHEME} & the scheme for generating absolute URLs; default is
\texttt{http}.  This packet is useful if \emph{beng-proxy} is behind
\texttt{stunnel} \\

\hline
\texttt{STATUS} & HTTP status code, encoded as \texttt{uint16\_t};
this parameter is usually not used \\
\hline

\texttt{PATH} & Absolute path of the local file to be served (see
\ref{static}). \\

\hline

\texttt{PROXY} & this URL parameter may be specified instead of
\texttt{PATH} to tell \emph{beng-proxy} to obtain the resource from a
remote HTTP server (see \ref{http}) \\

\hline

\texttt{AJP} & Load the resource from an AJPv13 server (see
\ref{ajp}). \\

\hline

\texttt{PIPE} & a local program which reads input from stdin and
prints the modified resource on stdout (see \ref{pipe}). \\

\hline

\texttt{APPEND} & appends an argument to the command line of the
preceding \texttt{PIPE} \\

\hline

\texttt{CGI} & a local path which is executed as CGI script \\

\hline

\texttt{FASTCGI} & a local path which is executed as FastCGI script \\

\hline

\texttt{REDIRECT} & another alternative to \texttt{PATH}: redirect the
HTTP client to this URL; \texttt{STATUS} must be set to one of the
HTTP 3xx codes \\

\hline

\texttt{PATH\_INFO} & optional URI substring which was left after
finding the file \\

\hline

\texttt{SITE} & optional identification or name of the site this
resource belongs to \\

\hline

\texttt{DOCUMENT\_ROOT} & base directory of the site; may also be
passed after a \texttt{CGI}/\texttt{DELEGATE} command, to set the
document root only for this CGI/delegate \\

\hline

\texttt{CONTENT\_TYPE} & MIME type of the file (optional) \\

\hline

\texttt{DELEGATE} & After \texttt{PATH}: delegates opening the file to
a program.  The payload is the path of the delegate program.  See
section \ref{delegate} for details. \\

\hline

\texttt{BASE} & Defines a realm in the URI space.  The payload
specifies the URI prefix (of the original request URI, ending with a
slash) which contains this
realm.  All resources in this realm can be addressed by
\emph{beng-proxy} with a trivial pattern: append the relative URI
(within the realm) to the resource address (e.g. the \texttt{PATH},
\texttt{PROXY} or \texttt{PATH\_INFO} value).

The address in this response applies to request URI, not the
base URI (to allow backwards compatibility with translation clients
which do not support this packet).

Example: in the request, \texttt{URI} is \texttt{/foo/bar/index.html};
in the response, \texttt{PATH} is \texttt{/var/www/foo/bar/index.html}
and \texttt{BASE} is \texttt{/foo/}.  The \emph{beng-proxy}
translation cache now knows: if a request on \texttt{/foo/test.png} is
received, it can serve \texttt{/var/www/foo/test.png} without querying
the translation server. \\

\hline

\texttt{FILTER} & the next resource address (\texttt{PROXY},
\texttt{CGI}) will denote an output filter, see section \ref{filter}
\\

\hline

\texttt{PROCESS} & enables the \emph{beng-proxy} processor, see
section \ref{processor} \\

\hline

\texttt{DOMAIN} & the domain name for partitioned frames \\

\hline

\texttt{SESSION} & a session identifier generated by the translation
server, see section \ref{sessions} \\

\hline

\texttt{USER} & the user name associated with this session \\

\hline

\texttt{LANGUAGE} & overrides the \texttt{Accept-Language} request
header for this session \\
\hline

\texttt{DISCARD\_SESSION} & discard the current browser session \\

\hline

\texttt{JAILCGI} & enable JailCGI \\

\hline

\texttt{INTERPRETER} & run a CGI script with the specified
interpreter; does not require the ``execute'' bit on the CGI script \\

\hline

\texttt{ACTION} & run the specified CGI program \\

\hline

\texttt{SCRIPT\_NAME} & the \texttt{SCRIPT\_NAME} environment variable
for a CGI \\

\hline

\texttt{ADDRESS} & after each \texttt{PROXY} packet, there must be one
or more \texttt{ADDRESS} packets which specify the resolved addresses.
The payload of each is a \texttt{struct sockaddr}.
The same applies to \texttt{AJP} packets. \\

\hline

\texttt{VIEW} & starts a new view; the body of the packet is the name
of the view (ASCII letters, digits, underscore, dash only).  Each view
can have different processor/filter settings.  The first view (the one
before the first \texttt{VIEW} packet) is the default and has no
name.  The root template has only the default view. \\

\hline

\texttt{MAX\_AGE} & a 32 bit unsigned integer specifying the number of
seconds the preceding piece of information is valid without having to
revalidate.  A value of 0 specifies that \emph{beng-proxy} should not
remember this value at all.  Without this packet, the maximum age is
not limited.  Currently, this is only supported for the following
packets:

\texttt{BEGIN} (refers to the whole translate response), \texttt{USER}
\\

\hline

\texttt{VARY} & similar to the HTTP \texttt{Vary} response header;
the payload contains an array of translation request commands which
this response depends upon.

The following request packets are currently supported:
\texttt{SESSION},
\texttt{LOCAL\_ADDRESS},
\texttt{REMOTE\_HOST}, \texttt{HOST}, \texttt{LANGUAGE},
\texttt{USER\_AGENT}, \texttt{QUERY\_STRING}.

\\

\hline

\texttt{INVALIDATE} & Invalidates existing translation cache items
which depend on some of the request values.  The payload has the same
format as \texttt{VARY}.  Additionally, the \texttt{URI} command is
supported, to invalidate all items pointing to the request URI.

If you specify more than one command, all must match.  If you list a
command which was not specified in the request (or a command which is
not supported here), nothing will be deleted.

Example: \texttt{INVALIDATE} on \texttt{SESSION} invalidates all cache
items for the current session.

\\

\hline

\texttt{REQUEST\_HEADER\_FORWARD} &

This packet specifies which request headers are forwarded to the
request handler.  The payload is a list of group/mode pairs
(\texttt{struct beng\_header\_forward\_packet}).  Group is one of:

\begin{itemize}
\item \texttt{IDENTITY}: headers \texttt{Via} and
  \texttt{X-Forwarded-For}
\item \texttt{CAPABILITIES}: \texttt{Server}, \texttt{User-Agent},
  \texttt{Accept-*}
\item \texttt{COOKIE}: \texttt{Cookie[2]}, \texttt{Set-Cookie[2]}
\item \texttt{OTHER}: other end-to-end headers not explicitly
  mentioned here
\item \texttt{ALL}: all of the above
\end{itemize}

Mode is one of:

\begin{itemize}
\item \texttt{NO}: don't forward the headers
\item \texttt{YES}: forward the headers
\item \texttt{MANGLE}: \emph{beng-proxy} processes the headers
\end{itemize}

\emph{beng-proxy}'s session management is only active when
\texttt{COOKIE} is \texttt{MANGLE} (which is the default).  The
behavior of the \texttt{COOKIE} setting on widgets is undefined.

\\

\hline

\texttt{RESPONSE\_HEADER\_FORWARD} &

Same as \texttt{REQUEST\_HEADER\_FORWARD}, but applies to response
headers forwarded to the client. \\

\hline
\end{longtable}

If the translation server does not provide the \texttt{CONTENT\_TYPE}
header, \emph{beng-proxy} will attempt to discover the file type from
its extended attributes (see \ref{xattr}).

To send a standard error page, the translation server sends a response
containing only the \texttt{STATUS} parameter with the desired HTTP
status.

\subsubsection{Proxying requests}

When proxying HTTP requests with the a \texttt{PROXY} packet,
\emph{beng-proxy} forwards the request to the specified location,
including the HTTP method and the request body.  There is one
exception: if \texttt{PROCESS} is enabled and a widget is focused, the
other HTTP server receives a \texttt{GET} request without a body,
because the focused widget is going to receive the request body.

If the filter URL starts with a slash, \emph{beng-proxy} assumes it is
the absolute path to a Unix socket.

\subsubsection{Filters}
\label{filter}

The translation server can tell \emph{beng-proxy} to apply a filter to
the resource by sending the \texttt{FILTER} command.  It is followed
by a packet specifying the filter server (\texttt{PROXY},
\texttt{CGI}, \texttt{FASTCGI}, \texttt{AJP}).

A filter server is a HTTP server.  \emph{beng-proxy} sends the
original resource with a POST request and expects the filtered
resource as response.

It is important that a filter is completely stateless.  Running the
same filter twice on the same source must always render the same
result, at any time.

There may be more than one filter; the order of the \texttt{PROCESS}
and \texttt{FILTER} packets is important.

According to the HTTP specification, POST requests are not cached.  To
gain the necessary performance, \emph{beng-proxy} caches filter
results, extending the HTTP specification.  This is limited to
resources which have an \emph{ETag} response header, because
\emph{beng-proxy} uses the \emph{ETag} internally to address cache
items.

\subsubsection{Sessions}
\label{sessions}

\emph{beng-proxy} lets the translation server manage a ``session''
variable, which may be empty, or contain a opaque string.  It is up to
the translation server to manage its contents.  With every translation
request, \emph{beng-proxy} sends its contents unless it is empty (in
which case it omits this parameter).  With every response, the
translation server may provide a new value (which may be empty).

\subsubsection{Widget registry}

The translation server provides access to the widget database, where
all widget servers are registered.  A widget request can use the
following packets:

\begin{longtable}{|l|p{10cm}|}
\hline
\texttt{WIDGET\_TYPE} & the name of the widget type \\
\hline
\end{longtable}

The translation server's response consists of these packets:

\begin{longtable}{|l|p{8cm}|}
\hline
\texttt{STATUS} & in case of a lookup error, this packet provides the
HTTP status code \\
\hline

\texttt{PATH}, \texttt{CGI}, \texttt{PROXY} & choose one of these
packets: a static widget (local file path), a local CGI script, or a
HTTP server \\

\hline

\texttt{DOCUMENT\_ROOT}, \texttt{JAILCGI} & optional flags for CGI
widgets \\

\hline
\texttt{PROCESS} & enable the BENG processor \\
\hline
\texttt{CONTAINER} & this widget can contain other widgets \\

\hline

\texttt{HOST} & sets the externally visible host name for requests
which are proxied to this widget.  This marks the widget as
``untrusted'' and disallows any other way of embedding it.  This is
useful for widget code whose JavaScript must not be executed in the
same context as another widget. \\

\hline

\texttt{STATEFUL} & remember the state of this widget, i.e. path info
and query string \\

\hline
\end{longtable}


\section{Widget protocol}

A widget server is simply an HTTP server.  Its content type must be
\texttt{text/html} or \texttt{text/xml}.


\subsection{Hyperlinks}

A widget may provide hyperlinks, e.g. with anchor elements or with
FORM elements.

``Internal links'' are links which are relative to the widget's base
URI - these links can be loaded into the widget's dock.  In CGI, this
feature is called ``PATH\_INFO''.  An internal link may include a
query string.

``External URIs'' are not relative, they should
load in a new browser window.

\subsection{Redirection}

Widgets can send the usual HTTP redirection responses (status
\texttt{3xx}).  The new location must be below the widget's base URI.

\emph{beng-proxy} is currently limited to sending a \texttt{GET}
request following the redirect, because it does not save the request
body.  This is always correct for ``303 See Other'', but may not be
for the other redirection types.  Widget servers should therefore
always redirect with ``303 See Other'' as follow-up to a POST request.

\subsection{POSTing and other methods}

Making the browser send a request body with a POST request is
possible.  It is recommended that you send a ``303 See Other''
redirect as a response to a POST request.  Always reckon that
\emph{beng-proxy} may request a resource multiple times, even without
interaction of the browser.

The same is true for other HTTP methods: \texttt{PUT}, \texttt{DELETE}
and others are passed to the focused widget.

\subsection{Session tracking}

A widget may use HTTP cookies for session tracking, even if the
browser does not support it - \emph{beng-proxy} will take care of it.
The widget should not include some kind of session identification in
the URI.

These cookies are not available in JavaScript.  Besides that, it would
be a bad practice to use cookies in JavaScript which are not actually
evaluated by the server (and cannot be used by the widget server in
this case, since \emph{beng-proxy} does not forward them).  These
cookies would generate a lot of network load for no good, which would
have to go through the visitor's narrow upstream with every request.

It is recommended to use (cookie based) sessions only if really
required.  In many situations, there are more elegant solutions, like
storing the current state of a widget in its current URI (path info).

\subsection{Authentification}

There is currently no support for HTTP based authentification.

Authentification is supported in the translation protocol.  After the
translation server sets the \texttt{USER} session variable to a
non-empty string, the session is presumed to be authenticated.  This
user variable is passed to widget servers in the proprietary
\texttt{X-CM4all-BENG-User} request header.  The user is logged out
when the translation sends an empty \texttt{USER} packet.

XXX further explanation, samples


\subsection{Payment}

It is planned to make \emph{beng-proxy} support pay-per-view widgets
(the webmaster paying to the widget provider).  No further details are
known yet.


\subsection{Referrer}

The \texttt{Referer} request header is not supported.


\section{The Beng Template Language}
\label{processor}

The \emph{beng-proxy} template language defines commands which may be
inserted into XHTML stream.  They are implemented as XML elements and
attributes with the prefix \texttt{c:}.  If you care about validating
the processor input, you must declare the XML namespace \texttt{c:}.
There is currently no suggested namespace URI, and \emph{beng-proxy}
does not actually care, because it does not implement a full-featured
XML parser.

\subsection{Adding a widget}

To add a widget, use the following command:

\begin{verbatim*}
<c:widget id="foo" type="date" />
\end{verbatim*}

The following attributes may be specified:

\begin{longtable}{|l|p{8cm}|}
\hline
\texttt{id} & unique identification of this widget; this is required
for proper session and form management if there are several widgets
with the same server URI \\
\hline
\texttt{type} & registered name of the widget server \\

\hline

\texttt{display} & specifies how the widget is to be displayed:
\texttt{inline} is the default, and inserts the widget's HTML code
into the current page; \texttt{none} does not display the widget, but
it may be referenced later (see section \ref{frames}) \\

\hline
\texttt{session} & the scope of the widget session (which widgets with
the same id share the same session data?): \texttt{resource} is the
default and means that two documents have different sessions;
\texttt{site} means documents in the same site share session data \\

\hline
\end{longtable}

Registered widgets are not yet implemented.

\subsection{Passing arguments to widgets}

\begin{verbatim*}
<c:widget id="foo" type="date">
  <c:parameter name="timezone" value="PST" />
  <c:path-info value="/bla" />
</c:widget>
\end{verbatim*}

\texttt{parameter} elements adds query string parameters.  These are
added to the query string provided by the browser.

There may be one \texttt{path-info} element whose value is appended to
the widget URI, if none was sent by the browser.

As usual: never trust user input!  The widget server cannot see if
input came from the template or from the user's browser.

\subsection{Passing HTTP headers to widgets}

\begin{verbatim*}
<c:widget id="foo" type="date">
  <c:header name="X-CM4all-Foo" value="Bar" />
</c:widget>
\end{verbatim*}

\texttt{header} elements create HTTP request headers.  Headers are
added, not replaced, i.e. you cannot use this to overwrite existing
headers.  In the header name, only letters, digits and the dash is
allowed.  It must start with ``X-''.

Again: never trust user input!  The widget server cannot see if input
came from the template or from the user's browser.

\subsection{Selecting the widget view}

\begin{verbatim*}
<c:widget id="foo" type="bar">
  <c:view name="raw"/>
</c:widget>
\end{verbatim*}

The \texttt{c:view} element selects the transformation view for this
widget.  It can be one of the view names provided by the widget
registry (i.e. the translation server).

\subsection{Variable substitutions}

\emph{beng-proxy} defines special entities beginning with \texttt{c:}
for its purposes.  Namespaced entities are not actually allowed in XML
or HTML, and this is only an interim solution until the javascript
filter is finished.  These entities are (unlike normal HTML entities)
also expanded in \texttt{SCRIPT} elements.

\begin{tabular}{|l|p{8cm}|}
\hline
\texttt{\&c:path;} & the location of this widget \\
\hline
\texttt{\&c:prefix;} & XML id and Javascript prefix \\
\hline
\texttt{\&c:uri;} & absolute external URI of the current page; use
this variable for redirecting \\
\hline

\texttt{\&c:base;} & base URI of the current page (i.e. without
\emph{beng-proxy} arguments and without the query string) \\

\hline
\texttt{\&c:frame;} & the top widget in this frame (if any) \\
\hline
\texttt{\&c:session;} & the current session id \\
\hline
\end{tabular}

\subsection{Relative URIs}
\label{rewrite}

Relative links are difficult with \emph{beng-proxy}, because the
browser interprets links as relative to the document by default.  A
widget author cannot specify a link relative to the widget itself.  To
allow this, \emph{beng-proxy} can rewrite relative links to the
following bases:

\begin{tabular}{|l|p{10cm}|}
\hline

\texttt{template} & links are relative to the main template (default)
\\

\hline

\texttt{widget} & links are relative to the widget; the browser will
leave \emph{beng-proxy} if the user clicks on such a link, because it
points to the widget server \\

\hline

\texttt{child} & link to a child widget; the URI is the ID of the
child widget.  You may append a relative URI separated by a slash. \\

\hline

\texttt{parent} & links are relative to the parent of this widget,
i.e. the container which declared it \\

\hline
\end{tabular}

The base name must be specified in the element attribute
\texttt{c:base} before the attribute containing the URI.  To specify
the mode of the rewritten URI, you may use the attribute
\texttt{c:mode}:

\begin{tabular}{|l|p{10cm}|}
\hline

\texttt{direct} & direct link to the resource \\

\hline

\texttt{focus} & link to \emph{beng-proxy} serving the full page (or
the current frame), focusing the widget \\

\hline

\texttt{partial} & link to \emph{beng-proxy} serving only the selected
widget; useful for frame contents \\

\hline

\texttt{partition} & same as \texttt{partial}, but try to provide a
link to a different host name (provided by the \texttt{DOMAIN}
translation packet) \\

\hline

\texttt{proxy} & \textbf{Deprecated}: use \texttt{partial} with a raw
view instead \\

\hline
\end{tabular}

The mode is ignored when the base is ``\texttt{template}''.

\emph{beng-proxy} knows the following HTML elements, and optionally
rewrites URIs:

\begin{itemize}
\item \texttt{A}
\item \texttt{AUDIO}
\item \texttt{EMBED}
\item \texttt{FORM}
\item \texttt{IFRAME}
\item \texttt{IMG}
\item \texttt{SCRIPT}
\item \texttt{VIDEO}
\end{itemize}

Example:

\begin{verbatim*}
<img c:base="widget" c:mode="proxy" src="foo.jpg"/>
\end{verbatim*}

\subsubsection{Processing Instruction syntax}

To set a default value for all following link elements, you may use
the \texttt{<?cm4all-rewrite-uri?>} XML Processing Instruction:

\begin{verbatim*}
<?cm4all-rewrite-uri c:base="widget" c:mode="focus"?>
\end{verbatim*}

This is recommended when many adjacent links share the same URI
rewrite settings, or when you cannot guarantee the order of attributes
(many XSLT processors mix the attribute order, which is allowed).

\subsection{Frames}
\label{frames}

\emph{beng-proxy} supports displaying widgets in an \texttt{IFRAME} or
\texttt{IMG} element.  To do this, declare your widget with
\texttt{display=none}.  After that, insert an \texttt{IFRAME} element
(or any other element which references its content with an URI), and
let \emph{beng-proxy} rewrite the URI:

\begin{verbatim}
<c:widget id="post" type="demo_post" display="none"/>
<iframe width="200" height="200" c:base="child"
  c:mode="partial" src="post"/>
\end{verbatim}

This may be used for any HTML tag which is supported by the
\emph{beng-proxy} URI rewriting code, here an example for a widget
rendering an image:

\begin{verbatim}
<c:widget id="logo" type="logorenderer" display="none"/>
<img c:base="child" c:mode="proxy" src="logo"
  alt="Our website logo"/>
\end{verbatim}

Note that we use \texttt{c:mode=proxy} here, because an image should
not (and can not) be processed by \emph{beng-proxy}.  You can also use
\texttt{c:mode=direct} if you want the browser to request the resource
from widget server directly instead of proxying through
\emph{beng-proxy}.


\section{The Beng JavaScript API}

JavaScript code in a widget frequently needs to send HTTP requests to
the widget server.  All these requests must got through
\emph{beng-proxy}.  Since the structure of a \emph{beng-proxy} URI is
regarded internal, it provides a JavaScript function to generate such
an URI:

\begin{verbatim*}
function
beng_widget_uri(base_uri, session_id, frame, focus, mode,
                path, translate, view);
\end{verbatim*}

The return value is the URI which can be safely requested by the
widget server.  For \texttt{base\_uri}, \texttt{session\_id},
\texttt{frame}, you should pass the value of \texttt{\&c:base;},
\texttt{\&c:session;}, \texttt{\&c:frame;}.

\texttt{focus} is the path of the focused widget, and can be filled
with \texttt{\&c:path;} most of the time, unless you can to request a
different widget than the current one.

\texttt{mode} is one of the following:

\begin{longtable}{|l|p{11cm}|}
\hline

\texttt{focus} & the full page (the default if \texttt{null} is
passed) \\

\hline

\texttt{partial} & just this one widget, processor enabled (must be
\texttt{text/html}) \\

\hline
\texttt{proxy} &
\textbf{Deprecated}: use \texttt{partial} and the \texttt{view}
parameter instead \\
\hline
\end{longtable}

The \texttt{path} argument is an URI relative to the widget.  It may
include a query string.

The \texttt{translate} argument is passed to the translation server as
\texttt{PARAM} packet.

\texttt{view} is the name of the transformation view to use.  This
parameter is ignored unless \texttt{frame} is set, or \texttt{mode} is
``\texttt{partial}''.


\section{The prototype translation server}

Until the \texttt{jetserv} daemon is finished, the prototype
translation server should be used.  It is not configurable; this
section describes its hard-coded behaviour.

\subsection{Request translation}

The document root is \texttt{/var/www}.  File names ending with
\texttt{.html} are mapped to the content type ``text/html;
charset=utf-8'' and are marked with the flags \texttt{PROCESS},
\texttt{CONTAINER}.

\subsection{Widget registry}

The translation server excepts a file for each registered widget type
named \texttt{/etc/cm4all/beng/widgets/TYPENAME}.  Example:

\begin{verbatim*}
server "http://cfatest01.intern.cm-ag/date.py"
process
container
\end{verbatim*}

The first line is mandatory: it specifies the widget server.
\texttt{process} enables the template processor; if that is not
specified, the HTML output is inserted into the resulting page
verbatim.  \texttt{container} allows the widget to embed sub widgets,
\texttt{stateful} sets the ``stateful'' flag.

Disabling features may increase the performance dramatically, because
it allows \emph{beng-proxy} to make better assumptions on data it does
not know yet.  So if you know the widget is a leaf widget, do not
specify \texttt{container}.

Instead of \texttt{server}, you can use \texttt{cgi} to specify the
absolute path of a CGI script which will serve the widget, or
\texttt{path} for a static widget.

For CGI widgets, you can also specify the options
\texttt{script\_name}, \texttt{docu\-ment\_root}, \texttt{action},
\texttt{interpreter} and \texttt{jailcgi}.

\end{document}
