\documentclass[a4paper,12pt]{article}

\begin{document}
\title{CM4all Beng}
\author{Max Kellermann}

\maketitle

\begin{abstract}
Beng proxy is an HTTP server including an HTTP proxy and a
minimalistic template processor.  Its goal is to dynamically aggregate
a web site from a number of sources (widgets).
\end{abstract}


\section{Features}

Beng-proxy delivers resources via HTTP.  In the most simple form, it
it provides a resource in pass-through mode, acting as an HTTP proxy.

It caches resources if possible.

XML resources can be transformed with XSLT.

On HTML resources, it can apply a simple template language.  This
language provides commands to insert another HTML page, which is
called \textbf{Widget}.

\subsection{Widgets}

A \textbf{Widget} is an object which can be inserted into a web site.
It is rendered by a Widget server into HTML.

We do not assume that we can trust the widget server.  As a
consequence, we have to ensure that a malicious widget server cannot
compromise the security of \emph{beng-proxy}, the client or even other
widget servers.

There is a global registry for well-known preconfigured widgets.  The
user can also choose to run his own (non-registered) widget server.
In fact, any public HTTP server should be able to act as a widget
server.


\subsection{Cookies}

\emph{beng-proxy} can be accessed with cookies switched off.  It includes a
full-featured session management and provides cookies for the widget
servers.

\emph{beng-proxy} maintains the client's session id in either a cookie
or as part of the URI.  In its local session storage, it holds all
cookies which were created by the widget servers.  This way, the
client gets to see only the one session id, disregarding how much
session information may be managed by \emph{beng-proxy}.


\subsection{JavaScript}

Since all widgets are put together into a single HTML page, all of the
JavaScript runs in the same security context.  That will open the door
for malicious widget servers, which are now able to take over the full
web site, including all other widgets.  For that reason, JavaScript is
only allowed for very few well-known and trusted widget servers.  For
all other widget servers, JavaScript use is rejected, or it must be
embedded in an IFRAME, which has technical and practical
disadvantages.


\subsection{Forms}

\emph{beng-proxy} itself does not use the HTTP query string or POST
data.  All of it can be handed off to a widget.  To enable this,
\emph{beng-proxy} rewrites forms, and remembers which widget server to
send the data to.


\section{Translation}

\emph{beng-proxy} knows two ways to locate the resource a request URI
points to:

\begin{itemize}
\item via an external translation server
\item static translation
\end{itemize}

The latter is only for debugging.

\subsection{Static translation}

The URI path is appended to the document root (\texttt{/var/www} by
default).

\subsubsection{Content type}
\label{xattr}

In contrast to most other web servers, \emph{beng-proxy} does not use
the file name to determine the \texttt{Content-Type} response header.
Instead, it reads this information from \textit{extended attributes}.
The programs \texttt{getfattr} and \texttt{setfattr} (Debian package
\texttt{attr}) enable you to read and write attributes:

\begin{verbatim*}
setfattr -n user.Content-Type -v "text/html; charset=utf8" \
/var/www/index.html
\end{verbatim*}

Some file systems need explicit support for extended attributes (mount
option \texttt{user\_xattr}).  On
XFS, extended attributes are always enabled.

\subsubsection{Directory index}

For security (by obscurity) reasons, \emph{beng-proxy} has no code for
generating directory listings.  If the request has a trailing slash,
\emph{beng-proxy} looks for a file named \texttt{index} or
\texttt{index.html} and serves it.  Without the trailing slash,
\emph{beng-proxy} refuses to handle the request.


\subsection{Translation server}

The translation server should be the default on production servers.
It is an daemon on the same physical machine which does all the
translation work for us.  \emph{beng-proxy} connects to a Unix socket
to contact this translation server.

A request may consist of several micro commands.  The request is
initialized with the \texttt{TRANSLATE} command, which is followed by
any number of commands which provide parameters.  After all parameters
have been transferred, the client sends the \texttt{END} command,
which tells the translation server to execute the request.  The client
now waits for the server's response, which has a similar structure.

The client can send any number of requests over the socket until one
side closes the connection.

\subsubsection{Example conversation}

\begin{itemize}
\item client sends \texttt{TRANSLATE}
\item client sends \texttt{HOST} ``www.example.com''
\item client sends \texttt{URI} ``/foo/index.html''
\item client sends \texttt{END}
\item server sends \texttt{TRANSLATE}
\item server sends \texttt{PATH} ``/var/www/foo/index.html''
\item server sends \texttt{CONTENT\_TYPE} ``text/html; charset=utf8''
\item server sends \texttt{END}
\end{itemize}

\subsubsection{Command packets}

The protocol is binary and uses host byte order.  A command packet may
look like this in pseudo C:

\begin{verbatim}
struct beng_proxy_translate_packet {
    uint16_t length;
    uint16_t command;
    char payload[length];
};
\end{verbatim}

The \texttt{length} only refers to the payload.  The maximum supported
payload size is 65535 bytes.

Most parameters are ASCII strings; in this case the payload contains
just the raw string, without terminating zero.

\subsubsection{Request}

\begin{tabular}{|l|p{10cm}|}
\hline
\texttt{HOST} & the \texttt{Host} HTTP request header \\
\hline
\texttt{URI} & the URI from the HTTP request \\
\hline
\texttt{SESSION} & a session identifier generated by the translation
server, see \ref{sessions} \\
\hline
\end{tabular}

\subsubsection{Response}

\begin{tabular}{|l|p{10cm}|}
\hline
\texttt{STATUS} & HTTP status code, encoded as \texttt{uint16\_t};
this parameter is usually not used \\
\hline
\texttt{PATH} & absolute path of the local file to be served \\
\hline
\texttt{CONTENT\_TYPE} & MIME type of the file (optional) \\
\hline
\texttt{PROXY} & this URL parameter may be specified instead of
\texttt{PATH} to tell \emph{beng-proxy} to obtain the resource from a
remote HTTP server (proxy mode) \\
\hline
\texttt{REDIRECT} & another alternative to \texttt{PATH}: redirect the
HTTP client to this URL; \texttt{STATUS} must be set to one of the
HTTP 3xx codes \\
\hline
\texttt{FILTER} & absolute URL of the filter, see \ref{filter} \\
\hline
\texttt{PROCESS} & enables the \emph{beng-proxy} processor \\
\hline
\texttt{SESSION} & a session identifier generated by the translation
server, see \ref{sessions} \\
\hline
\texttt{UNSET\_SESSION} & unsets the session identifier \\
\hline
\end{tabular}

If the translation server does not provide the \texttt{CONTENT\_TYPE}
header, \emph{beng-proxy} will attempt to discover the file type from
its extended attributes (see \ref{xattr}).

To send a standard error page, the translation server sends a response
containing only the \texttt{STATUS} parameter with the desired HTTP
status.  It should however not check whether the resource exists.

\subsubsection{Filters}
\label{filter}

The translation server can tell \emph{beng-proxy} to apply a filter to
the resource by sending the \texttt{FILTER} command.  This is an
absolute URL which points to a HTTP server.  \emph{beng-proxy} sends
the original resource with a POST request and expects the filtered
resource as response.

If the filter URL starts with a slash, \emph{beng-proxy} assumes it is
the absolute path to a Unix socket.

\subsubsection{Sessions}
\label{sessions}

\emph{beng-proxy} lets the translation server manage a ``session''
variable, which may be unset, empty, or contain a opaque string.  It
is up to the translation server to manage its contents.  With every
translation request, \emph{beng-proxy} sends its contents unless it is
unset (in which case it omits this parameter).  With every response,
the translation server may provide a new value or unset it.


\section{Widget protocol}

A widget server is simply an HTTP server.  Its content type must be
text/html.  Alternatively, text/xml is allowed, but the caller must
specify an XSLT file for transformation to HTML.


\subsection{Hyperlinks}

A widget may provide hyperlinks, e.g. with anchor elements or with
FORM elements.

``Internal links'' are links which are relative to the widget's base
URI - these links can be loaded into the widget's dock.  In CGI, this
feature is called ``PATH\_INFO''.  An internal link may include a
query string.

``External URIs'' are not relative, they should
load in a new browser window.

\subsection{POSTing}

Making the browser send a request body with a POST request is
possible.  Note however that \emph{beng-proxy} may be very aggressive
about caching POST responses.  To prevent that, you should send a
``303 See Other'' redirect as a response to a POST request.  The same
is valid for every request which modifies a resource - always reckon
that \emph{beng-proxy} may request a resource multiple times, even
without interaction of the browser.

\subsection{Session tracking}

A widget may use HTTP cookies for session tracking, even if the
browser does not support it - \emph{beng-proxy} will take care of it.
The widget should not include some kind of session identification in
the URI.

Cookies are not available in JavaScript.

\subsection{Authentification}

Authentification is not yet supported.

\subsection{Payment}

It is planned to make \emph{beng-proxy} support pay-per-view widgets
(the webmaster paying to the widget provider).  No further details are
known yet.


\subsection{Referrer}

The \texttt{Referer} request header is not supported.


\section{The Beng Template Language}

The \emph{Beng} template language defines commands which may be
inserted in the form of XML processing instructions.

\subsection{Adding a widget}

To add a widget, insert the following command:

\begin{verbatim*}
<c:widget id="foo" href="http://cfatest01.intern.cm-ag/date.py" />
\end{verbatim*}

The following attributes may be specified:

\begin{tabular}{|l|p{8cm}|}
\hline
\texttt{id} & unique identification of this widget; this is required
for proper session and form management if there are several widgets
with the same server URI \\
\hline
\texttt{name} & registered name of the widget server \\
\hline
\texttt{href} & use an unregistered widget \\
\hline
\texttt{query\_string} & optional query string to append to the widget
URI (without the question mark) \\
\hline
\texttt{display} & specifies how the widget is to be displayed:
\texttt{inline} is the default, and inserts the widget's HTML code
into the current page; \texttt{iframe} puts the widget into an
\texttt{IFRAME}; \texttt{img} means the widget generates an image, and
it will be referenced from an \texttt{IMG} element \\
\hline
\texttt{width}, \texttt{height} & dimensions of the widget \\
\hline
\end{tabular}

Registered widgets are not yet implemented.

\subsection{Passing arguments to widgets}

\begin{verbatim*}
<c:widget id="foo" href="http://cfatest01.intern.cm-ag/date.py">
  <param name="timezone" value="PST" />
  <path-info value="/bla" />
</c:widget>
\end{verbatim*}

\texttt{param} elements create query string parameters.  The query
string generated by this is appended to an existing query string
provided by the browser.

There may be one \texttt{path-info} element whose value is appended to
the widget URI.

As usual: never trust user input!  The widget server cannot see if
input came from the template or from the user's browser.

\subsection{Variable substitutions}

\emph{beng-proxy} defines special entities beginning with \texttt{c:}
for its purposes.

\begin{tabular}{|l|p{8cm}|}
\hline
\texttt{\&c:path;} & the location of this widget \\
\hline
\texttt{\&c:prefix;} & XML id and Javascript prefix \\
\hline
\end{tabular}


\end{document}
