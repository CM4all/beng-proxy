\documentclass[a4paper,12pt]{article}
\usepackage[pdftex,bookmarks]{hyperref}
\usepackage{longtable}

\setlength\LTleft{0pt}
\setlength\LTright{0pt}

\begin{document}
\title{CM4all Beng}
\author{Max Kellermann}

\maketitle

\begin{abstract}
Beng proxy is an HTTP server including an HTTP proxy and a
minimalistic template processor.  Its goal is to dynamically aggregate
a web site from a number of sources (widgets).
\end{abstract}

\setcounter{tocdepth}{2}
\tableofcontents
\newpage

\section{Features}

Beng-proxy delivers resources via HTTP.  In the most simple form, it
it provides a resource in pass-through mode, acting as an HTTP proxy.

It caches resources if possible.

It can filter any resources by POSTing it to a HTTP server,
e.g. to apply XSLT to a XML resource.

On HTML resources, it can apply a simple template language.  This
language provides commands to insert another HTML page, which is
called \textbf{Widget}.

\subsection{Widgets}

A \textbf{Widget} is an object which can be inserted into a web site.
It is rendered by a Widget server into HTML.

We do not assume that we can trust the widget server.  As a
consequence, we have to ensure that a malicious widget server cannot
compromise the security of \emph{beng-proxy}, the client or even other
widget servers.

There is a global registry for well-known preconfigured widgets.  The
user can also choose to run his own (non-registered) widget server.
In fact, any public HTTP server should be able to act as a widget
server.


\subsection{Cookies}

\emph{beng-proxy} can be accessed with cookies switched off.  It includes a
full-featured session management and provides cookies for the widget
servers.

\emph{beng-proxy} maintains the client's session id in either a cookie
or as part of the URI.  In its local session storage, it holds all
cookies which were created by the widget servers.  This way, the
client gets to see only the one session id, disregarding how much
session information may be managed by \emph{beng-proxy}.


\subsection{JavaScript}

Since all widgets are put together into a single HTML page, all of the
JavaScript runs in the same security context.  That will open the door
for malicious widget servers, which are now able to take over the full
web site, including all other widgets.  For that reason, only
well-known and trusted widget servers should be allowed to be inlined.
All other widget must be embedded in an IFRAME in another domain.


\subsection{Forms}

\emph{beng-proxy} itself does not use the query string and the request
body.  Both is forwarded to the ``focused'' widget.  See \ref{rewrite}
for information on widget focus.


\section{Installation}

\emph{beng-proxy} requires a Debian Lenny operating system: Linux
kernel 2.6.26 and glibc 2.7.  For compiling the source code, you need
a C99 compiler, e.g. gcc 4.3.

Install the package \texttt{cm4all-beng-proxy} and the translation
server of your choice.  Edit the file
\texttt{/etc/default/cm4all-beng-proxy}, and set the port number and
the path of the translation server socket.  Set the \texttt{WORKERS}
variable to the number of CPU cores in that server (or up to twice as
large).  Finally, restart \emph{beng-proxy}:

\begin{verbatim*}
/etc/init.d/cm4all-beng-proxy restart
\end{verbatim*}

\subsection{Configuration options}

The command line argument \texttt{--set} allows you to tweak some
settings:

\begin{longtable}{|l|p{8cm}|}
\hline

\texttt{session\_cookie} & The name of the session cookie.  The
default value is ``beng\_proxy\_session''. \\ \hline

\texttt{session\_idle\_timeout} & After this duration (in seconds), a
session expires, unless it gets refreshed by a request. \\

\hline

\texttt{max\_connections} & The maximum number of incoming HTTP
connections. \\
\hline

\texttt{tcp\_stock\_limit} & The maximum number of outgoing TCP
connections per remote host.  0 means unlimited, which has shown to be
a bad choice, because many servers do not scale well. \\

\hline

\texttt{fastcgi\_stock\_limit} & The maximum number of child processes
for one FastCGI application.  0 means unlimited. \\

\hline

\texttt{was\_stock\_limit} & The maximum number of child processes for
one WAS application.  0 means unlimited. \\

\hline

\texttt{http\_cache\_size} & The maxmimum amount of memory used by the
HTTP cache.  Set to 0 to disable the HTTP cache. \\

\hline

\texttt{filter\_cache\_size} & The maxmimum amount of memory used by
the filter cache.  Set to 0 to disable the filter cache. \\

\hline

\texttt{translate\_cache\_size} & The maxmimum number of cached
translation server responses.  Set to 0 to disable the translate
cache. \\

\hline

\texttt{stopwatch} & Set to \texttt{yes} to enable the stopwatch.  See
\ref{stopwatch} for details. \\

\hline

\texttt{enable\_splice} & Set to \texttt{no} to disable the
\texttt{splice()} system call (enabled by default).  This may degrade
the server performance, and is only intended to work around kernel
bugs. \\

\hline

\texttt{dump\_widget\_tree} & Set to \texttt{yes} to dump the widget
tree for each request into the log file. \\

\hline
\end{longtable}

\label{memcached}
You may specify \texttt{--memcached-server} followed by a server name.
This disables the local heap cache, and allows \emph{beng-proxy} to
share the cache with several (distributed) workers.  With the local
heap cache disabled, all of its configuration options are ignored.

\label{bulldog}
With \texttt{--bulldog-path}, \emph{beng-proxy} reads status
information on servers it contacts from the Bulldog-Tyke data
directory.

\subsection{Cluster Options}

To run \emph{beng-proxy} as a \emph{beng-lb} cluster node with sticky
sessions, each node needs special configuration.  It needs to generate
new session numbers in a way that allows \emph{beng-lb} to derive the
cluster node from it.

To do that, specify the two command line options
\texttt{--cluster-size} and \texttt{--cluster-node} to each
\emph{beng-proxy} node.  Example for a cluster with 3 nodes:

\begin{verbatim*}
first# cm4all-beng-proxy --cluster-size=3 --cluster-node=0 ...
second# cm4all-beng-proxy --cluster-size=3 --cluster-node=1 ...
third# cm4all-beng-proxy --cluster-size=3 --cluster-node=2 ...
\end{verbatim*}

Each node number is assigned to exactly one cluster node.

The according \texttt{lb.conf} would look like this:

\begin{verbatim*}
pool foo {
  sticky "session_modulo"
  member first:http
  member second:http
  member third:http
}
\end{verbatim*}

The ordering of nodes matters.

\section{Running}

\subsection{Signals}

\texttt{SIGTERM} on the master process initiates shutdown.

On \texttt{SIGHUP}, the error log file is reopened and all caches are
flushed.


\section{Tuning}

\subsection{Optimized Build}

The default package \texttt{cm4all-beng-proxy} is built with debugging
code enabled.  It is about 2-10 times slower than the optimized build.
If performance really counts, you should install the package
\texttt{cm4all\--beng\--proxy\--optimized} instead (and restart the
daemon).

To switch back to the debug build, uninstall
\texttt{cm4all\--beng\--proxy\--op\-ti\-mi\-zed} and then reinstall
\texttt{cm4all\--beng\--proxy} to get the old
\texttt{/usr/sbin/cm4all\--beng\--proxy} back.  Finally, restart the
daemon.

\subsection{Resource Limits}

\emph{beng-proxy} needs to open a lot of file handles at a time,
because it serves many connections in one process.  Make sure that the
file handle limit is adequate.  The default init script sets it to
65536.  The only reason set that limit at all is to detect bugs (file
descriptor leaks).

Keep in mind that \emph{beng-proxy} may open more than one file
descriptor per connection.  For example, a connection to a WAS
application needs 3 file descriptors.

\subsection{Connection Limits}

\emph{beng-proxy} is very good at managing lots of incoming
connections, and manages system resources economically.  The default
value is 8192.

There are good reasons to limit the number of outgoing connections per
host (\texttt{tcp\_stock\_limit}): most servers don't handle so many
connections as well as \emph{beng-proxy}, and performance degrades
when there are too many.  By default, there is no limit.

\subsection{Firewall}

Benchmarks have demonstrated that Netfilter (and its connection
tracking) account for a good amount of the CPU load on a busy server.
A good server does not need to depend on a firewall for security:
rather than blocking protocols and ports, the administrator should
make sure that these services aren't bound to public interfaces in the
first place.  An internal services bound on all interfaces is an
indicator for misconfiguration.

It is a good idea to disable the firewall (in the kernel
configuration) and audit all listeners.  If you cannot do without a
firewall, you can disable connection tracking for \emph{beng-proxy}
connections:

\begin{verbatim*}
table raw {
  chain PREROUTING proto tcp dport http NOTRACK;
  chain OUTPUT proto tcp sport http NOTRACK;
}
\end{verbatim*}

\subsection{Cacheable Widgets and Containers}

If you do a lot of direct communication with widgets, its container
should be cacheable.  If not, the container will be queried each time
a request for a widget is handled.  On pages with many widgets, you
should try to make all of them cacheable.  See \ref{caching} for
details.

\subsection{Disabling Widget Options}

Don't enable widget options when you don't need them.  That affects
the options ``processor'', ``container'', ``stateful'' and others.
Each of them adds some bloat to the response handler, and slows down
the application.  See \ref{registry} for details.

\subsection{Load Balancing}

If a machine serving a resource is too slow, you may be able to
parallelize its work.  Note that this increases throughput, but
usually does not reduce latency considerably.  See \ref{balancing}.

\subsection{The Stopwatch}
\label{stopwatch}

The stopwatch measures the latency of external resources (e.g. remote
HTTP servers, CGI and pipe programs).  It is only available in the
debug build (compile-time option \texttt{--enable-stopwatch}).

Example output:

\begin{verbatim*}
stopwatch[172.30.0.23:80 /test.py]: request=5ms headers=85ms
end=88ms (beng-proxy=1+2ms)
\end{verbatim*}

Here, the HTTP request to \texttt{172.30.0.23:80} was sent within 5
milliseconds.  After 85 milliseconds, the response headers were
received, and after 3 more milliseconds, the response body was
received.  All of these refer to wallclock time, relative to the start
of the operation.  Each client library may have its own set of
breakpoints.

During this HTTP request, \emph{beng-proxy} consumed 3 milliseconds or
raw CPU time (not wallclock time): 1 millisecond in user space, and 2
milliseconds for the kernel.

\section{Resources}

\emph{beng-proxy} delivers resources to its HTTP clients.  It obtains
these resources from several sources.

\subsection{Static files}
\label{static}

Local ``regular'' files can be served by \emph{beng-proxy}.  This is
the fastest mode, and should be preferred, if possible.  The
\texttt{Range} request header is supported (bytes only).

\subsubsection{Content type}

\label{xattr}

In contrast to most other web servers, \emph{beng-proxy} does not use
the file name to determine the \texttt{Content-Type} response header.
Instead, it reads this information from \textit{extended attributes}.
The programs \texttt{getfattr} and \texttt{setfattr} (Debian package
\texttt{attr}) enable you to read and write attributes:

\begin{verbatim*}
setfattr -n user.Content-Type -v "text/html; charset=utf8" \
/var/www/index.html
\end{verbatim*}

Some file systems need explicit support for extended attributes (mount
option \texttt{user\_xattr}).  On
XFS, extended attributes are always enabled.

\subsubsection{ETag}

The \texttt{ETag} response header is read from the \texttt{user.ETag}
extended attribute (see \ref{xattr}).  If none is present, it is
generated from the inode number and the modification time.  The request
headers \texttt{If-Match} and \texttt{If-None-Match} are supported.

\subsubsection{Expires}

If the \texttt{user.MaxAge} attribute exists, it is parsed as a
decimal integer.  The \texttt{Expires} response header is then
generated by adding this number of seconds to the current time stamp.
The maximum accepted value for \texttt{user.MaxAge} is one year.

\subsubsection{Directory index}

For security (by obscurity) reasons, \emph{beng-proxy} has no code for
generating directory listings.

\subsection{Delegates}
\label{delegate}

A ``delegate'' is a helper program which opens a local file and passes
the file descriptor to \emph{beng-proxy}.  The major reason for using
a delegate is to take advantage of the kernel's validation: the
delegate program may run with different privileges, different resource
limits or in a chroot/vserver.

The delegate reads requests on standard input.  The protocol is
similar to the translation protocol.  The file descriptor is sent to
\emph{beng-proxy} in a \texttt{SOL\_SOCKET} ancillary message.

If the \texttt{DELEGATE} translation packet was followed by a
\texttt{DOCUMENT\_ROOT} packet, then all helper processes are grouped
by their document root, and text \texttt{DOCUMENT\_ROOT} environment
variable is set.  In this case, it is possible to run the delegate
helper inside JailCGI by specifying the \texttt{JAILCGI} packet.

\subsection{HTTP proxying}
\label{http}

\emph{beng-proxy} implements an HTTP client, which allows it to act as
a reverse HTTP proxy server.  You should never make \emph{beng-proxy}
connect to itself.

\subsubsection{Caching}
\label{caching}

Responses from the remote servers are cached, if possible.  To allow
proper caching, the remote server must set the response headers
\texttt{Last-Modified}, \texttt{Expires} and \texttt{ETag} properly.
Additionally, they should understand the according request headers
\texttt{If-Modified-Since} and \texttt{If-Unmodified-Since},
\texttt{If-Match}, \texttt{If-None-Match}.

The cache is local to a \emph{beng-proxy} worker.  To share the cache
across workers and even across hosts, you may use a memcached server
(see \ref{memcached}).

\subsubsection{Connection pooling}

\emph{beng-proxy} attempts to use HTTP 1.1 keep-alive, to be able to
reuse existing connections to a remote server.

\subsubsection{Load balancing, failover}
\label{balancing}

For a remote URL, more than one server may be specified.
\texttt{beng-proxy} tries to use all of these equally.  If one server
fails on the socket level, \texttt{beng-proxy} ignores it for a short
amount of time.

Advanced users may take advantage of Bulldog-Tyke data, by passing
the option \texttt{--bulldog-path} (see \ref{bulldog}).

\subsubsection{Forwarded headers}

Not all request and response headers are forwarded, for various
reasons:

\begin{itemize}
\item hop-by-hop headers (RFC 2616 13.5.1) must not be forwarded
\item headers describing the body are not forwarded if there is no
  body
\item cookie forwarding and \texttt{beng-proxy}'s own session
  management are mutually exclusive
\item some headers reveal otherwise private information about the
  communication partner at the other end (e.g. IP address)
\item some servers rely on the authenticity of the
  \texttt{X-CM4all-BENG-User} header
\item due to imponderable security implications, much of the header
  forwarding is opt-in
\end{itemize}

By default, only the following original request headers are forwarded
to the remote HTTP server:

\begin{itemize}
\item the \texttt{Accept-*} headers
\item \texttt{User-Agent}
\item \texttt{Cache-Control}
\item in the presence of a forwarded request body:
  \texttt{Content-Type} and the other \texttt{Content-*} headers
\item \texttt{Cookie2} is taken from the current session
\end{itemize}

Response headers forwarded to \texttt{beng-proxy}'s client:

\begin{itemize}
\item \texttt{Age}, \texttt{ETag}, \texttt{Cache-Control},
  \texttt{Last-Modified}, \texttt{Retry-After}, \texttt{Vary},
  \texttt{Location}
\item \texttt{Content-Type} and the other \texttt{Content-*} headers
\item \texttt{Set-Cookie2} is generated from the current session
\end{itemize}

The translation server can change the header forwarding policy, see
\ref{tfwdheader}.

\subsection{AJP v1.3}
\label{ajp}

Similar to HTTP proxying, \emph{beng-proxy} can act as a HTTP-to-AJP
bridge.

The AJP client also supports caching, connection pooling and load
balancing.

\subsection{CGI and FastCGI}
\label{cgi}

Local CGI programs may be used to generate dynamic resources.
\emph{beng-proxy} supports running these with JailCGI.

CGI/FastCGI resources are cached in the same manner as remote HTTP
resources.

\subsection{Pipe filters}
\label{pipe}

A pipe is a program which filters a resource by reading it from
standard input, and writing the result to standard output.  This
option cannot be used to generate a resource, but only for resource
filters.  The same can be achieved with CGI, but pipes are simpler to
implement, because they do not need to bother with HTTP status code
and headers.


\section{Translation}

\emph{beng-proxy} knows two ways to locate the resource a request URI
points to:

\begin{itemize}
\item via an external translation server
\item static translation
\end{itemize}

The latter is only for debugging.  The URI path is appended to the
document root (\texttt{/var/www} by default).  For security (by
obscurity) reasons, \emph{beng-proxy} has no code for generating
directory listings.  If the request has a trailing slash,
\emph{beng-proxy} looks for a file named \texttt{index} or
\texttt{index.html} and serves it.  Without the trailing slash,
\emph{beng-proxy} refuses to handle the request.

The translation server should be the default on production servers.
It is a daemon on the same physical machine which does all the
translation work for us.  \emph{beng-proxy} connects to a Unix socket
to contact this translation server.

A request may consist of several micro commands.  The request is
initialized with the \texttt{BEGIN} command, which is followed by any
number of commands which provide parameters.  After all parameters
have been transferred, the client sends the \texttt{END} command,
and waits for the server's response.

The client can send any number of requests over the socket until one
side closes the connection.

\subsection{Example conversation}

\begin{itemize}
\item client sends \texttt{BEGIN}
\item client sends \texttt{REMOTE\_HOST} ``192.168.1.77:1234''
\item client sends \texttt{HOST} ``www.example.com''
\item client sends \texttt{URI} ``/foo/index.html''
\item client sends \texttt{END}
\item server sends \texttt{BEGIN}
\item server sends \texttt{PATH} ``/var/www/foo/index.html''
\item server sends \texttt{CONTENT\_TYPE} ``text/html; charset=utf8''
\item server sends \texttt{PROCESS}
\item server sends \texttt{END}
\end{itemize}

\subsection{Command packets}

The protocol is binary and uses host byte order.  A command packet may
look like this in pseudo C:

\begin{verbatim}
struct beng_proxy_translate_packet {
    uint16_t length;
    uint16_t command;
    char payload[length];
};
\end{verbatim}

The \texttt{length} only refers to the payload.  The maximum supported
payload size is 65535 bytes.

Most parameters are ASCII strings; in this case, the payload contains
just the raw string, without terminating zero.

\subsection{Request}

\begin{longtable}{|l|p{10cm}|}
\hline

\texttt{LOCAL\_ADDRESS} & The local socket address the request was
received on.  The payload is a \texttt{struct sockaddr}. \\

\hline

\texttt{REMOTE\_HOST} & the client's address or host name and the port
number (as string) \\

\hline
\texttt{HOST} & the \texttt{Host} HTTP request header \\
\hline
\texttt{URI} & the raw URI from the HTTP request (without the query
string) \\
\hline

\texttt{QUERY\_STRING} & the query string from request URI, without
the question mark \\

\hline
\texttt{SESSION} & a session identifier generated by the translation
server, see section \ref{sessions} \\
\hline
\texttt{PARAM} & a parameter passed by the browser \\

\hline

\texttt{USER\_AGENT} & the \texttt{User-Agent} request header sent by
the client (not in the widget registry) \\

\hline

\texttt{LANGUAGE} & the \texttt{Accept-Language} request header sent
by the client (not in the widget registry) \\

\hline

\texttt{AUTHORIZATION} & the \texttt{Authorization} request header
sent by the client (see RFC 2617) \\

\hline

\texttt{ERROR\_DOCUMENT} & a resource has failed, and the translation
server is asked to provide the location of the error document.  This
is followed by the packets \texttt{URI} and \texttt{STATUS}.  See
\ref{errdoc} for a detailed description. \\

\hline

\texttt{CHECK} & causes beng-proxy to submit the same translation
request again, with this packet appended (its payload is opaque to
\emph{beng-proxy}).  The current response is remembered, to be used
when the second response contains the \texttt{PREVIOUS} packet.  This
can be used to implement authentication (see \ref{authentication}). \\

\hline

\texttt{PREVIOUS} & Tells beng-proxy to use the resource address of
the previous translation response.  Only allowed if the request
contains a \texttt{CHECK} packet. \\

\hline

\end{longtable}

\subsection{Response}

\begin{longtable}{|l|p{8cm}|}

\hline

\texttt{URI} & the ``real'' raw URI from the HTTP request (without the
query string); this is used to override the URI, e.g. when
\emph{beng-proxy} is behind another proxy which modifies the URI \\

\hline

\texttt{HOST} & the host name for generating absolute URLs; default is
the \texttt{Host} HTTP request header \\

\hline

\texttt{SCHEME} & the scheme for generating absolute URLs; default is
\texttt{http}.  This packet is useful if \emph{beng-proxy} is behind
\texttt{stunnel} \\

\hline

\texttt{UNTRUSTED} & sets the ``untrusted'' host name for this
request: only untrusted widgets matching this host name are allowed.
Trusted widgets are rejected. \\

\hline
\texttt{STATUS} & HTTP status code, encoded as \texttt{uint16\_t};
this parameter is usually not used \\
\hline

\texttt{PATH} & Absolute path of the local file to be served (see
\ref{static}). \\

\hline

\texttt{DEFLATED} & Absolute path of a precompressed version of the
file.  The file is compressed with the ``deflate'' algorithm, without
\texttt{gzip} headers.  May follow the \texttt{PATH} packet. \\

\hline

\texttt{GZIPPED} & Absolute path of a precompressed version of the
file.  The file is compressed with \texttt{gzip}.  May follow the
\texttt{PATH} packet. \\

\hline

\texttt{PROXY} & this URL parameter may be specified instead of
\texttt{PATH} to tell \emph{beng-proxy} to obtain the resource from a
remote HTTP server (see \ref{http}) \\

\hline

\texttt{AJP} & Load the resource from an AJPv13 server (see
\ref{ajp}).  The payload of this packet is an absolute URI in the form
\texttt{ajp://host:port/path} \\

\hline

\texttt{PIPE} & a local program which reads input from stdin and
prints the modified resource on stdout (see \ref{pipe}). \\

\hline

\texttt{APPEND} & appends an argument to the command line of the
preceding \texttt{PIPE} \\

\hline

\texttt{CGI} & a local path which is executed as CGI script \\

\hline

\texttt{FASTCGI} & a local path which is executed as FastCGI script.
To connect to an existing FastCGI server, specify one or more
\texttt{ADDRESS} packets. \\

\hline

\texttt{WAS} & a local path which is executed as WAS application \\

\hline

\texttt{PAIR} & adds a FastCGI/WAS parameter or CGI environment
variable in the form \texttt{KEY=VALUE}. \\

\hline

\texttt{REDIRECT} & another alternative to \texttt{PATH}: redirect the
HTTP client to this URL; \texttt{STATUS} must be set to one of the
HTTP 3xx codes \\

\hline

\texttt{BOUNCE} & Redirects the browser with a \texttt{303 See Other}
status to this URI, and appends the current absolute URI
(form-encoded).  This is useful to redirect to another server, which
will need to redirect back to the original URI. \\

\hline

\texttt{PATH\_INFO} & optional URI substring which was left after
finding the file \\

\hline

\texttt{SITE} & optional identification or name of the site this
resource belongs to \\

\hline

\texttt{DOCUMENT\_ROOT} & base directory of the site; may also be
passed after a \texttt{CGI}/\texttt{DELEGATE} command, to set the
document root only for this CGI/delegate \\

\hline

\texttt{CONTENT\_TYPE} & MIME type of the file (optional) \\

\hline

\texttt{DELEGATE} & After \texttt{PATH}: delegates opening the file to
a program.  The payload is the path of the delegate program.  See
section \ref{delegate} for details. \\

\hline

\texttt{BASE} & Defines a realm in the URI space.  The payload
specifies the URI prefix (of the original request URI, ending with a
slash) which contains this
realm.  All resources in this realm can be addressed by
\emph{beng-proxy} with a trivial pattern: append the relative URI
(within the realm) to the resource address (e.g. the \texttt{PATH},
\texttt{PROXY} or \texttt{PATH\_INFO} value).

The address in this response applies to request URI, not the
base URI (to allow backwards compatibility with translation clients
which do not support this packet).

Example: in the request, \texttt{URI} is \texttt{/foo/bar/index.html};
in the response, \texttt{PATH} is \texttt{/var/www/foo/bar/index.html}
and \texttt{BASE} is \texttt{/foo/}.  The \emph{beng-proxy}
translation cache now knows: if a request on \texttt{/foo/test.png} is
received, it can serve \texttt{/var/www/foo/test.png} without querying
the translation server. \\

\hline

\texttt{FILTER} & the next resource address (\texttt{PROXY},
\texttt{CGI}) will denote an output filter, see section \ref{filter}
\\

\hline

\texttt{FILTER\_4XX} & Enable filtering of client errors (status 4xx).
Without this flag, only successful responses (2xx) are filtered.  Only
useful when at least one \texttt{FILTER} was specified. \\

\hline

\texttt{PROCESS} & enables the \emph{beng-proxy} processor, see
section \ref{processor} \\

\hline

\texttt{PROCESS\_CSS} & enables the \emph{beng-proxy} CSS processor \\

\hline

\texttt{DOMAIN} & the domain name for partitioned frames \\

\hline

\texttt{SESSION} & a session identifier generated by the translation
server, see section \ref{sessions} \\

\hline

\texttt{USER} & the user name associated with this session \\

\hline

\texttt{REALM} & a realm name for this session.  An existing session
matches only if its realm matches the current request's realm.  If
this packet is not specified in the translation response, then the
``Host'' request header is used. \\

\hline

\texttt{TRANSPARENT} & Transparent proxy: forward URI arguments to the
request handler instead of using them.  As a side effect, session
handling is disabled. \\

\hline

\texttt{LANGUAGE} & overrides the \texttt{Accept-Language} request
header for this session \\
\hline

\texttt{DISCARD\_SESSION} & discard the current browser session \\

\hline

\texttt{SECURE\_COOKIE} & Set the "secure" flag on the session cookie. \\

\hline

\texttt{JAILCGI} & enable JailCGI \\

\hline

\texttt{HOME} & home directory of the account this site belongs to;
will be mounted in the jail; defaults to \texttt{DOCUMENT\_ROOT} \\

\hline

\texttt{INTERPRETER} & run a CGI script with the specified
interpreter; does not require the ``execute'' bit on the CGI script \\

\hline

\texttt{ACTION} & run the specified CGI program \\

\hline

\texttt{SCRIPT\_NAME} & the \texttt{SCRIPT\_NAME} environment variable
for a CGI \\

\hline

\texttt{ADDRESS} & after each \texttt{PROXY} packet, there must be one
or more \texttt{ADDRESS} packets which specify the resolved addresses.
The payload of each is a \texttt{struct sockaddr}.
The same applies to \texttt{AJP} packets. \\

\hline

\texttt{STICKY} & Make the resource address "sticky", i.e. attempt to
forward all requests of a session to the same worker. \\

\hline

\texttt{VIEW} & starts a new view; the body of the packet is the name
of the view (ASCII letters, digits, underscore, dash only).  Each view
can have different address/processor/filter settings.  The first view
(the one before the first \texttt{VIEW} packet) is the default and has
no name.  The root template has only the default view. \\

\hline

\texttt{MAX\_AGE} & a 32 bit unsigned integer specifying the number of
seconds the preceding piece of information is valid without having to
revalidate.  A value of 0 specifies that \emph{beng-proxy} should not
remember this value at all.  Without this packet, the maximum age is
not limited.  Currently, this is only supported for the following
packets:

\texttt{BEGIN} (refers to the whole translate response), \texttt{USER}
\\

\hline

\texttt{VARY} & similar to the HTTP \texttt{Vary} response header;
the payload contains an array of translation request commands which
this response depends upon.

The following request packets are currently supported:
\texttt{SESSION},
\texttt{LOCAL\_ADDRESS},
\texttt{REMOTE\_HOST}, \texttt{HOST}, \texttt{LANGUAGE},
\texttt{USER\_AGENT}, \texttt{QUERY\_STRING}.

\\

\hline

\texttt{INVALIDATE} & Invalidates existing translation cache items
which depend on some of the request values.  The payload has the same
format as \texttt{VARY}.  Additionally, the \texttt{URI} command is
supported, to invalidate all items pointing to the request URI.

If you specify more than one command, all must match.  If you list a
command which was not specified in the request (or a command which is
not supported here), nothing will be deleted.

Example: \texttt{INVALIDATE} on \texttt{SESSION} invalidates all cache
items for the current session.

\\

\hline

\label{tfwdheader}
\texttt{REQUEST\_HEADER\_FORWARD} &

This packet specifies which request headers are forwarded to the
request handler.  The payload is a list of group/mode pairs
(\texttt{struct beng\_header\_forward\_packet}).  Group is one of:

\begin{itemize}
\item \texttt{IDENTITY}: headers \texttt{Via} and
  \texttt{X-Forwarded-For}
\item \texttt{CAPABILITIES}: \texttt{Server}, \texttt{User-Agent},
  \texttt{Accept-*}
\item \texttt{COOKIE}: \texttt{Cookie[2]}, \texttt{Set-Cookie[2]}
\item \texttt{OTHER}: other end-to-end headers not explicitly
  mentioned here
\item \texttt{ALL}: all of the above
\end{itemize}

Mode is one of:

\begin{itemize}
\item \texttt{NO}: don't forward the headers
\item \texttt{YES}: forward the headers
\item \texttt{MANGLE}: \emph{beng-proxy} processes the headers
\end{itemize}

\emph{beng-proxy}'s session management is only active when
\texttt{COOKIE} is \texttt{MANGLE} (which is the default).  The
behavior of the \texttt{COOKIE} setting on widgets is undefined.

\\

\hline

\texttt{RESPONSE\_HEADER\_FORWARD} &

Same as \texttt{REQUEST\_HEADER\_FORWARD}, but applies to response
headers forwarded to the client. \\

\hline

\texttt{WWW\_AUTHENTICATE} & the \texttt{WWW-Authenticate} response
header sent to the client (see RFC 2617).  Currently, this is never
cached.  This exact behavior is subject to change in the future, and
will be cacheable. \\

\hline

\texttt{AUTHENTICATION\_INFO} & the \texttt{Authentication-Info}
response header sent to the client (see RFC 2617). \\

\hline

\texttt{HEADER} & A custom HTTP response header sent to the client.
Name and value are separated by a colon (without any whitespace).
This will not override existing headers.  It is not allowed to set
hop-by-hop headers (RFC 2616 13.5.1) this way.  This packet shall only
be a last resort, when there is no other way to set a required
response header. \\

\hline

\texttt{ERROR\_DOCUMENT} & Indicates that the translation server is
willing to provide a custom error document. \\

\hline

\texttt{COOKIE\_HOST} & Override the cookie host name.  This host name
is used for storing and looking up cookies in the jar.  It is
especially useful for protocols that don't have a host name, such as
CGI. \\

\hline
\end{longtable}

If the translation server does not provide the \texttt{CONTENT\_TYPE}
header, \emph{beng-proxy} will attempt to discover the file type from
its extended attributes (see \ref{xattr}).

To send a standard error page, the translation server sends a response
containing only the \texttt{STATUS} parameter with the desired HTTP
status.

\subsection{Proxying requests}

When proxying HTTP requests with the a \texttt{PROXY} packet,
\emph{beng-proxy} forwards the request to the specified location,
including the HTTP method and the request body.  There is one
exception: if \texttt{PROCESS} is enabled and a widget is focused, the
other HTTP server receives a \texttt{GET} request without a body,
because the focused widget is going to receive the request body.

If the filter URL starts with a slash, \emph{beng-proxy} assumes it is
the absolute path to a Unix socket.

\subsection{Filters}
\label{filter}

The translation server can tell \emph{beng-proxy} to apply a filter to
the resource by sending the \texttt{FILTER} command.  It is followed
by a packet specifying the filter server (\texttt{PROXY},
\texttt{CGI}, \texttt{FASTCGI}, \texttt{AJP}).

A filter server is a HTTP server.  \emph{beng-proxy} sends the
original resource with a POST request and expects the filtered
resource as response.

It is important that a filter is completely stateless.  Running the
same filter twice on the same source must always render the same
result, at any time.

There may be more than one filter; the order of the \texttt{PROCESS}
and \texttt{FILTER} packets is important.

According to the HTTP specification, POST requests are not cached.  To
gain the necessary performance, \emph{beng-proxy} caches filter
results, extending the HTTP specification.  This is limited to
resources which have an \emph{ETag} response header, because
\emph{beng-proxy} uses the \emph{ETag} internally to address cache
items.

\subsection{Sessions}
\label{sessions}

\emph{beng-proxy} lets the translation server manage a ``session''
variable, which may be empty, or contain a opaque string.  It is up to
the translation server to manage its contents.  With every translation
request, \emph{beng-proxy} sends its contents unless it is empty (in
which case it omits this parameter).  With every response, the
translation server may provide a new value (which may be empty).

\subsection{Error documents}
\label{errdoc}

Errors from remote servers are forwarded to the client.  If no error
document is available, \emph{beng-proxy} generates a simple one.

The translation server indicates that it is willing to override the
error document by sending an empty \texttt{ERROR\_DOCUMENT} packet in
the translation response.  As soon as an error occurs (response status
400..599), \emph{beng-proxy} sends another translation request,
consisting of \texttt{ERROR\_DOCUMENT}, \texttt{URI} and
\texttt{STATUS}.

The translation server responds with a pointer to another resource
which shall be used as the error document.  If the translation
response is empty, or if the error document itself fails,
\emph{beng-proxy} forwards the original error document (or generates
one).  The error document cannot be filtered or processed.

\subsection{Widget registry}
\label{registry}

The translation server provides access to the widget database, where
all widget servers are registered.  A widget request can use the
following packets:

\begin{longtable}{|l|p{10cm}|}
\hline
\texttt{WIDGET\_TYPE} & the name of the widget type \\
\hline
\end{longtable}

The translation server's response consists of these packets:

\begin{longtable}{|l|p{8cm}|}
\hline
\texttt{STATUS} & in case of a lookup error, this packet provides the
HTTP status code \\
\hline

\texttt{PATH}, \texttt{CGI}, \texttt{PROXY} & choose one of these
packets: a static widget (local file path), a local CGI script, or a
HTTP server \\

\hline

\texttt{DOCUMENT\_ROOT}, \texttt{JAILCGI} & optional flags for CGI
widgets \\

\hline
\texttt{PROCESS} & enable the BENG processor \\
\hline
\texttt{CONTAINER} & this widget can contain other widgets \\

\hline

\texttt{UNTRUSTED} & sets the externally visible host name for requests
which are proxied to this widget.  This marks the widget as
``untrusted'' and disallows any other way of embedding it.  This is
useful for widget code whose JavaScript must not be executed in the
same context as another widget. \\

\hline

\texttt{UNTRUSTED\_PREFIX} & same as \texttt{UNTRUSTED}, but is a
prefix for the request host name.  This widget can only be used when
the request's \texttt{UNTRUSTED} packet begins with this prefix.
Example: \texttt{UNTRUSTED\_PREFIX="foo"} matches a request with
\texttt{UNTRUSTED="foo.example.com"}, but not
\texttt{UNTRUSTED="foobar.example.com"}. \\

\hline

\texttt{UNTRUSTED\_SITE\_SUFFIX} & similar to
\texttt{UNTRUSTED\_PREFIX}, but matches the suffix instead of the
prefix.  When generating untrusted URIs, the site name is prepended.
During verification, the request's \texttt{UNTRUSTED} value must
exactly match this scheme. \\

\hline

\texttt{STATEFUL} & remember the state of this widget, i.e. path info
and query string \\

\hline

\texttt{DUMP\_HEADERS} & Enable header dumps for the widget: on a HTTP
request, the request and response headers will be logged.  Only for
debugging purposes. \\

\hline
\end{longtable}


\section{Remote Control Protocol}

\emph{beng-proxy} can listen for multicast packets on a UDP port.
These packets contain one or more commands.  This is useful to notify
a whole cluster of \emph{beng-proxy} servers of an event.

UDP is, by design, a lossy protocol.  One must always consider that
not all nodes may have received a given packet.

The protocol does not implement authentication.  The commands are
designed in a way that they do not affect security.  However, it may
pose a weakness against DoS attacks, if an attacker manages to inject
packets into the internal network.

A command consists of a header containing length and command (network
byte order), and an optional payload.  The payload is padded with null
bytes to the next 4 byte border.

\subsection{Configuring}

The command line option \texttt{--control-listen} allows you to
specify an address to listen on, specify \texttt{*} to listen on all
interfaces.  The default port is 5478.

To enable IP multicast, set the multicast group address with
\texttt{--multicast-group}.

\subsection{Commands}

\begin{longtable}{|l|p{8cm}|}
\hline

\texttt{NOP} & ignored \\

\hline

\texttt{TCACHE\_INVALIDATE} & Invalidates translation cache entries.
This packet follows the same semantics as the \texttt{INVALIDATE}
translation response packet, but instead of passing just a list of
command numbers referring to a real translation request, you need to
send the values as well.  The payload of this packet consists of one
or more concatenated translation packets in network byte order, padded
with zeroes to multiples of 4 bytes.  \\

\hline
\end{longtable}


\section{Logging Protocol}

By default, accesses to HTTP resources are logged into the standard
log file (command-line option \texttt{--logger}).  The logging
protocol offers a more flexible alternative: a child process is
launched, connected to \texttt{beng-proxy} with a datagram socket.
Each datagram describes an event to be logged.

\subsection{Launching}

On startup, the logging process has a datagram socket on file
descriptor 0.  On this socket, it receives packets describing the
event.  File descriptor 2 is connected with the local error log, and
can be used to print fatal error messages.

\subsection{Datagram Format}

Each event is serialized into exactly one datagram.  That puts a limit
on the size of an event, and therefore, this protocol is designed to
be small but still easy enough to parse.

A datagram begins with the number 0x63046102 (32 bit), and is followed
by one or more attributes.  The first byte of each attribute is the
attribute id (see \texttt{enum beng\_log\_attribute} in
\texttt{beng-proxy/log.h}).  What follows is specific to the attibute
id.

General rules:

\begin{itemize}
\item there is no padding
\item all numbers are in network byte order (big endian)
\item strings are terminated by a null byte
\end{itemize}

\subsection{Configuring}

The command line option \texttt{--access-logger} receives the command
which launches the child process.  The command is executed with the
shell (\texttt{/bin/sh -c}).

\subsection{Included Loggers}

This section describes the loggers which are included in the Debian
package \texttt{cm4all-beng-proxy-logging}.

\subsubsection{\texttt{log-cat}}

Prints the events to standard output, which will be written to
\texttt{beng-proxy}'s error log file (as if you had not configured a
logger).  It has no arguments.

You can combine it with \texttt{multilog} or similar programs, for
example:

\begin{verbatim}
cm4all-beng-proxy-log-cat |multilog t /var/log/cm4all/access
\end{verbatim}

\subsubsection{\texttt{log-split}}

Splits the events into several log files.  The parameters are format
strings which are used to build the file name.  The first valid format
string is used.  Variables in the form \texttt{\%\{name\}} are
substituted; a format string is invalid if an unknown or undefined
variable is referenced.  If no valid format string is valid for an
event, nothing is logged.

Directories are auto-created if they do not exist.

The following variables are available:

\begin{tabular}{|l|p{8cm}|}
\hline
\texttt{date} & the date in the form YYYY-mm-dd \\
\hline
\texttt{year} & the year (4 digits) \\
\hline
\texttt{month} & the month (01..12) \\
\hline
\texttt{day} & the day of month (01..31) \\
\hline
\texttt{hour} & the hour (00..23) \\
\hline
\texttt{minute} & the minute (00..59) \\
\hline
\texttt{site} & the name of the ``site'' \\
\hline
\end{tabular}

Example:

\begin{verbatim}
cm4all-beng-proxy-log-split \
    /var/log/per-site/%{site}/%{date}.log \
    /var/log/unknown-site/%{year}.log
\end{verbatim}

\subsubsection{\texttt{log-forward}, \texttt{log-exec}}

\texttt{log-forward} forwards the events via UDP to a remote host.
The parameters are the IP addresses of the peers (there may be more
than one).

\begin{verbatim}
cm4all-beng-proxy-log-forward 192.168.1.133
\end{verbatim}

\texttt{log-exec} listens on a UDP port, and launches the real logger
bound to it:

\begin{verbatim}
daemon -o /var/log/access.log \
    cm4all-beng-proxy-log-exec '*' cm4all-beng-proxy-log-cat
\end{verbatim}

The first parameter is the IP address to bind to; ``*'' means listen
on all interfaces.

These two programs are useful in conjunction, to store logs on a
central server.


\section{Widget protocol}

A widget server is simply an HTTP server.  Its content type must be
\texttt{text/html} or \texttt{text/xml}.


\subsection{Hyperlinks}

A widget may provide hyperlinks, e.g. with anchor elements or with
FORM elements.

``Internal links'' are links which are relative to the widget's base
URI - these links can be loaded into the widget's dock.  In CGI, this
feature is called ``PATH\_INFO''.  An internal link may include a
query string.

``External URIs'' are not relative, they should
load in a new browser window.

\subsection{Redirection}

Widgets can send the usual HTTP redirection responses (status
\texttt{3xx}).  The new location must be below the widget's base URI.

\emph{beng-proxy} is currently limited to sending a \texttt{GET}
request following the redirect, because it does not save the request
body.  This is always correct for ``303 See Other'', but may not be
for the other redirection types.  Widget servers should therefore
always redirect with ``303 See Other'' as follow-up to a POST request.

\subsection{POSTing and other methods}

Making the browser send a request body with a POST request is
possible.  It is recommended that you send a ``303 See Other''
redirect as a response to a POST request.  Always reckon that
\emph{beng-proxy} may request a resource multiple times, even without
interaction of the browser.

The same is true for other HTTP methods: \texttt{PUT}, \texttt{DELETE}
and others are passed to the focused widget.

\subsection{Session tracking}

A widget may use HTTP cookies for session tracking, even if the
browser does not support it - \emph{beng-proxy} will take care of it.
The widget should not include some kind of session identification in
the URI.

These cookies are not available in JavaScript.  Besides that, it would
be a bad practice to use cookies in JavaScript which are not actually
evaluated by the server (and cannot be used by the widget server in
this case, since \emph{beng-proxy} does not forward them).  These
cookies would generate a lot of network load for no good, which would
have to go through the visitor's narrow upstream with every request.

It is recommended to use (cookie based) sessions only if really
required.  In many situations, there are more elegant solutions, like
storing the current state of a widget in its current URI (path info).

\subsection{Authentification}
\label{authentification}

There is currently no support for HTTP based authentification.

Authentification is supported in the translation protocol.  After the
translation server sets the \texttt{USER} session variable to a
non-empty string, the session is presumed to be authenticated.  This
user variable is passed to widget servers in the proprietary
\texttt{X-CM4all-BENG-User} request header.  The user is logged out
when the translation sends an empty \texttt{USER} packet.

\subsubsection{The \texttt{CHECK} packet}

On a protected resource, the translation server may send the
\texttt{CHECK} packet together with the normal response.  Now
\texttt{beng-proxy} queries the translation server again, sending the
same request and a copy of the \texttt{CHECK} packet.  The translation
server may now verify the current session, redirect to a login page,
or anything else needed to authenticate the user.  The response to
this second translation request may be a resource address as usual, or
the \texttt{PREVIOUS} packet, which indicates that the first
translation shall be used.

While the first response is usually cached for a long time, the second
one may specify a short texttt{MAX\_AGE} value.  This means the latter
is sent more often, but since it refers to the former, it is very
small.

Example 1, unauthenticated user logs in:

\begin{enumerate}
\item \emph{beng-proxy}: \texttt{URI=/protected/foo.html}
\item translation server: \texttt{PATH=/var/www/protected/foo.html
  SESSION=1234 CHECK=xyz}
\item \emph{beng-proxy}: \texttt{URI=/protected/foo.html SESSION=1234
  CHECK=xyz}
\item translation server: \texttt{MAX\_AGE=0 STATUS=403
  CGI=/usr/lib/cgi-bin/login.pl}
\item user enters his credentials, login.pl marks the session
  ``authenticated'', redirects back to the original URI
\item \emph{beng-proxy}: \texttt{URI=/protected/foo.html SESSION=1234
  CHECK=xyz} (from the cached translation response)
\item translation server: \texttt{MAX\_AGE=300 VARY=SESSION PREVIOUS}
\end{enumerate}

Example 2, authenticated user:

\begin{enumerate}
\item \emph{beng-proxy}: \texttt{URI=/protected/foo.html SESSION=2345}
\item translation server: \texttt{PATH=/var/www/protected/foo.html
  CHECK=xyz}
\item \emph{beng-proxy}: \texttt{URI=/protected/foo.html SESSION=2345
  CHECK=xyz}
\item translation server: \texttt{MAX\_AGE=300 VARY=SESSION PREVIOUS}
\end{enumerate}


\subsection{Payment}

It is planned to make \emph{beng-proxy} support pay-per-view widgets
(the webmaster paying to the widget provider).  No further details are
known yet.


\subsection{Referrer}

The \texttt{Referer} request header is not supported.


\section{The Beng Template Language}
\label{processor}

The \emph{beng-proxy} template language defines commands which may be
inserted into XHTML stream.  They are implemented as XML elements and
attributes with the prefix \texttt{c:}.  If you care about validating
the processor input, you must declare the XML namespace \texttt{c:}.
There is currently no suggested namespace URI, and \emph{beng-proxy}
does not actually care, because it does not implement a full-featured
XML parser.

\subsection{Adding a widget}

To add a widget, use the following command:

\begin{verbatim*}
<c:widget id="foo" type="date" />
\end{verbatim*}

The following attributes may be specified:

\begin{longtable}{|l|p{8cm}|}
\hline
\texttt{id} & unique identification of this widget; this is required
for proper session and form management if there are several widgets
with the same server URI \\
\hline
\texttt{type} & registered name of the widget server \\

\hline

\texttt{display} & specifies how the widget is to be displayed:
\texttt{inline} is the default, and inserts the widget's HTML code
into the current page; \texttt{none} does not display the widget, but
it may be referenced later (see section \ref{frames}) \\

\hline
\texttt{session} & the scope of the widget session (which widgets with
the same id share the same session data?): \texttt{resource} is the
default and means that two documents have different sessions;
\texttt{site} means documents in the same site share session data \\

\hline
\end{longtable}

Registered widgets are not yet implemented.

\subsection{Passing arguments to widgets}

\begin{verbatim*}
<c:widget id="foo" type="date">
  <c:parameter name="timezone" value="PST" />
  <c:path-info value="/bla" />
</c:widget>
\end{verbatim*}

\texttt{parameter} elements adds query string parameters.  These are
added to the query string provided by the browser.  In the value, the
standard XML entities \texttt{amp}, \texttt{quot}, \texttt{apos},
\texttt{lt}, \texttt{gt} are recognized.

There may be one \texttt{path-info} element whose value is appended to
the widget URI, if none was sent by the browser.

As usual: never trust user input!  The widget server cannot see if
input came from the template or from the user's browser.

\subsection{Passing HTTP headers to widgets}

\begin{verbatim*}
<c:widget id="foo" type="date">
  <c:header name="X-CM4all-Foo" value="Bar" />
</c:widget>
\end{verbatim*}

\texttt{header} elements create HTTP request headers.  Headers are
added, not replaced, i.e. you cannot use this to overwrite existing
headers.  In the header name, only letters, digits and the dash is
allowed.  It must start with ``X-''.

Again: never trust user input!  The widget server cannot see if input
came from the template or from the user's browser.

\subsection{Selecting the widget view}

\begin{verbatim*}
<c:widget id="foo" type="bar">
  <c:view name="raw"/>
</c:widget>
\end{verbatim*}

The \texttt{c:view} element selects the transformation view for this
widget.  It can be one of the view names provided by the widget
registry (i.e. the translation server).

\subsection{Variable substitutions}

\emph{beng-proxy} defines special entities beginning with \texttt{c:}
for its purposes.  Namespaced entities are not actually allowed in XML
or HTML, and this is only an interim solution until the javascript
filter is finished.  These entities are (unlike normal HTML entities)
also expanded in \texttt{SCRIPT} elements.

\begin{tabular}{|l|p{8cm}|}
\hline
\texttt{\&c:path;} & the location of this widget \\
\hline
\texttt{\&c:prefix;} & XML id and Javascript prefix \\
\hline
\texttt{\&c:uri;} & absolute external URI of the current page; use
this variable for redirecting \\
\hline

\texttt{\&c:base;} & base URI of the current page (i.e. without
\emph{beng-proxy} arguments and without the query string) \\

\hline
\texttt{\&c:frame;} & the top widget in this frame (if any) \\
\hline
\texttt{\&c:session;} & the current session id \\
\hline
\end{tabular}

\subsection{Relative URIs}
\label{rewrite}

Relative links are difficult with \emph{beng-proxy}, because the
browser interprets links as relative to the document by default.  A
widget author cannot specify a link relative to the widget itself.  To
allow this, \emph{beng-proxy} can rewrite relative links to the
following bases:

\begin{tabular}{|l|p{10cm}|}
\hline

\texttt{template} & links are relative to the main template (default)
\\

\hline

\texttt{widget} & links are relative to the widget; the browser will
leave \emph{beng-proxy} if the user clicks on such a link, because it
points to the widget server \\

\hline

\texttt{child} & link to a child widget; the URI is the ID of the
child widget.  You may append a relative URI separated by a slash. \\

\hline

\texttt{parent} & links are relative to the parent of this widget,
i.e. the container which declared it \\

\hline
\end{tabular}

The base name must be specified in the element attribute
\texttt{c:base} before the attribute containing the URI.  To specify
the mode of the rewritten URI, you may use the attribute
\texttt{c:mode}:

\begin{tabular}{|l|p{10cm}|}
\hline

\texttt{direct} & direct link to the resource \\

\hline

\texttt{focus} & link to \emph{beng-proxy} serving the full page (or
the current frame), focusing the widget \\

\hline

\texttt{partial} & link to \emph{beng-proxy} serving only the selected
widget; useful for frame contents \\

\hline

\texttt{partition} & same as \texttt{partial}, but try to provide a
link to a different host name (provided by the \texttt{DOMAIN}
translation packet) \\

\hline

\texttt{proxy} & \textbf{Deprecated}: use \texttt{partial} with a raw
view instead \\

\hline
\end{tabular}

The mode is ignored when the base is ``\texttt{template}''.

\emph{beng-proxy} knows the following HTML elements, and optionally
rewrites URIs:

\begin{itemize}
\item \texttt{A}
\item \texttt{AUDIO}
\item \texttt{EMBED}
\item \texttt{FORM}
\item \texttt{IFRAME}
\item \texttt{IMG}
\item \texttt{SCRIPT}
\item \texttt{VIDEO}
\end{itemize}

Example:

\begin{verbatim*}
<img c:base="widget" c:mode="proxy" src="foo.jpg"/>
\end{verbatim*}

\subsubsection{Processing Instruction syntax}

To set a default value for all following link elements, you may use
the \texttt{<?cm4all-rewrite-uri?>} XML Processing Instruction:

\begin{verbatim*}
<?cm4all-rewrite-uri c:base="widget" c:mode="focus"?>
\end{verbatim*}

This is recommended when many adjacent links share the same URI
rewrite settings, or when you cannot guarantee the order of attributes
(many XSLT processors mix the attribute order, which is allowed).

\subsection{Frames}
\label{frames}

\emph{beng-proxy} supports displaying widgets in an \texttt{IFRAME} or
\texttt{IMG} element.  To do this, declare your widget with
\texttt{display=none}.  After that, insert an \texttt{IFRAME} element
(or any other element which references its content with an URI), and
let \emph{beng-proxy} rewrite the URI:

\begin{verbatim}
<c:widget id="post" type="demo_post" display="none"/>
<iframe width="200" height="200" c:base="child"
  c:mode="partial" src="post"/>
\end{verbatim}

This may be used for any HTML tag which is supported by the
\emph{beng-proxy} URI rewriting code, here an example for a widget
rendering an image:

\begin{verbatim}
<c:widget id="logo" type="logorenderer" display="none"/>
<img c:base="child" c:mode="proxy" src="logo"
  alt="Our website logo"/>
\end{verbatim}

Note that we use \texttt{c:mode=proxy} here, because an image should
not (and can not) be processed by \emph{beng-proxy}.  You can also use
\texttt{c:mode=direct} if you want the browser to request the resource
from widget server directly instead of proxying through
\emph{beng-proxy}.

\subsection{Untrusted Widgets}

Usually, widgets are embedded inside the one single HTML page.  The
problem is that all scripts run with the same privileges, and each
widget's scripts can access the whole page, each widget can invoke
requests to any other widget.

As a safeguard against potentially malicious widgets,
\emph{beng-proxy} can run widgets in a separate domain.  The default
security settings of browsers will disallow cross-domain script
access.

To make a widget class ``untrusted'', the translation server generates
the \texttt{HOST} packet with a host name for that widget.  A host
name may be shared by a group of widget classes.

While translating a request, the translation server may send the
\texttt{UNTRUSTED} packet, repeating the host name of the request.
This makes the request itself ``untrusted'': trusted widgets are
rejected, and only those untrusted widgets matching the specified host
name are accepted.  If the packet is absend, all untrusted widgets are
rejected.


\section{The Beng JavaScript API}

JavaScript code in a widget frequently needs to send HTTP requests to
the widget server.  All these requests must got through
\emph{beng-proxy}.  Since the structure of a \emph{beng-proxy} URI is
regarded internal, it provides a JavaScript function to generate such
an URI:

\begin{verbatim*}
function
beng_widget_uri(base_uri, session_id, frame, focus, mode,
                path, translate, view);
\end{verbatim*}

The return value is the URI which can be safely requested by the
widget server.  For \texttt{base\_uri}, \texttt{session\_id},
\texttt{frame}, you should pass the value of \texttt{\&c:base;},
\texttt{\&c:session;}, \texttt{\&c:frame;}.

\texttt{focus} is the path of the focused widget, and can be filled
with \texttt{\&c:path;} most of the time, unless you can to request a
different widget than the current one.

\texttt{mode} is one of the following:

\begin{longtable}{|l|p{11cm}|}
\hline

\texttt{focus} & the full page (the default if \texttt{null} is
passed) \\

\hline

\texttt{partial} & just this one widget, processor enabled (must be
\texttt{text/html}) \\

\hline
\texttt{proxy} &
\textbf{Deprecated}: use \texttt{partial} and the \texttt{view}
parameter instead \\
\hline
\end{longtable}

The \texttt{path} argument is an URI relative to the widget.  It may
include a query string.

The \texttt{translate} argument is passed to the translation server as
\texttt{PARAM} packet.

\texttt{view} is the name of the transformation view to use.  This
parameter is ignored unless \texttt{frame} is set, or \texttt{mode} is
``\texttt{partial}''.


\section{The CSS Processor}
\label{cssprocessor}

The CSS processor is a transformation for cascading style sheets.  The
translation server enables it with the packet \texttt{PROCESS\_CSS}.
It is the equivalent of the HTML processor for CSS: it can convert
URLs to widget resources.  This allows proxying resources that are
referenced in CSS.


\section{The prototype translation server}

Until the \texttt{jetserv} daemon is finished, the prototype
translation server should be used.  It is not configurable; this
section describes its hard-coded behaviour.

\subsection{Request translation}

The document root is \texttt{/var/www}.  File names ending with
\texttt{.html} are mapped to the content type ``text/html;
charset=utf-8'' and are marked with the flags \texttt{PROCESS},
\texttt{CONTAINER}.

\subsection{Widget registry}

The translation server expects a file for each registered widget type
named \texttt{/etc/cm4all/beng/widgets/TYPENAME}.  Example:

\begin{verbatim*}
server "http://cfatest01.intern.cm-ag/date.py"
process
container
\end{verbatim*}

The first line is mandatory: it specifies the widget server.
\texttt{process} enables the template processor; if that is not
specified, the HTML output is inserted into the resulting page
verbatim.  \texttt{container} allows the widget to embed sub widgets,
\texttt{stateful} sets the ``stateful'' flag.

Disabling features may increase the performance dramatically, because
it allows \emph{beng-proxy} to make better assumptions on data it does
not know yet.  So if you know the widget is a leaf widget, do not
specify \texttt{container}.

Instead of \texttt{server}, you can use \texttt{cgi} to specify the
absolute path of a CGI script which will serve the widget, or
\texttt{path} for a static widget.

For CGI widgets, you can also specify the options
\texttt{script\_name}, \texttt{docu\-ment\_root}, \texttt{action},
\texttt{interpreter} and \texttt{jailcgi}.

\end{document}
