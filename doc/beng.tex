\documentclass[a4paper,12pt]{article}
\usepackage[pdftex,bookmarks]{hyperref}

\begin{document}
\title{CM4all Beng}
\author{Max Kellermann}

\maketitle

\begin{abstract}
Beng proxy is an HTTP server including an HTTP proxy and a
minimalistic template processor.  Its goal is to dynamically aggregate
a web site from a number of sources (widgets).
\end{abstract}

\setcounter{tocdepth}{2}
\tableofcontents
\newpage

\section{Features}

Beng-proxy delivers resources via HTTP.  In the most simple form, it
it provides a resource in pass-through mode, acting as an HTTP proxy.

It caches resources if possible.

XML resources can be transformed with XSLT.

On HTML resources, it can apply a simple template language.  This
language provides commands to insert another HTML page, which is
called \textbf{Widget}.

\subsection{Widgets}

A \textbf{Widget} is an object which can be inserted into a web site.
It is rendered by a Widget server into HTML.

We do not assume that we can trust the widget server.  As a
consequence, we have to ensure that a malicious widget server cannot
compromise the security of \emph{beng-proxy}, the client or even other
widget servers.

There is a global registry for well-known preconfigured widgets.  The
user can also choose to run his own (non-registered) widget server.
In fact, any public HTTP server should be able to act as a widget
server.


\subsection{Cookies}

\emph{beng-proxy} can be accessed with cookies switched off.  It includes a
full-featured session management and provides cookies for the widget
servers.

\emph{beng-proxy} maintains the client's session id in either a cookie
or as part of the URI.  In its local session storage, it holds all
cookies which were created by the widget servers.  This way, the
client gets to see only the one session id, disregarding how much
session information may be managed by \emph{beng-proxy}.


\subsection{JavaScript}

Since all widgets are put together into a single HTML page, all of the
JavaScript runs in the same security context.  That will open the door
for malicious widget servers, which are now able to take over the full
web site, including all other widgets.  For that reason, JavaScript is
only allowed for very few well-known and trusted widget servers.  For
all other widget servers, JavaScript use is rejected, or it must be
embedded in an IFRAME, which has technical and practical
disadvantages.


\subsection{Forms}

\emph{beng-proxy} itself does not use the HTTP query string or POST
data.  All of it can be handed off to a widget.  To enable this,
\emph{beng-proxy} rewrites forms, and remembers which widget server to
send the data to.


\section{Translation}

\emph{beng-proxy} knows two ways to locate the resource a request URI
points to:

\begin{itemize}
\item via an external translation server
\item static translation
\end{itemize}

The latter is only for debugging.

\subsection{Static translation}

The URI path is appended to the document root (\texttt{/var/www} by
default).

\subsubsection{Content type}
\label{xattr}

In contrast to most other web servers, \emph{beng-proxy} does not use
the file name to determine the \texttt{Content-Type} response header.
Instead, it reads this information from \textit{extended attributes}.
The programs \texttt{getfattr} and \texttt{setfattr} (Debian package
\texttt{attr}) enable you to read and write attributes:

\begin{verbatim*}
setfattr -n user.Content-Type -v "text/html; charset=utf8" \
/var/www/index.html
\end{verbatim*}

Some file systems need explicit support for extended attributes (mount
option \texttt{user\_xattr}).  On
XFS, extended attributes are always enabled.

\subsubsection{Directory index}

For security (by obscurity) reasons, \emph{beng-proxy} has no code for
generating directory listings.  If the request has a trailing slash,
\emph{beng-proxy} looks for a file named \texttt{index} or
\texttt{index.html} and serves it.  Without the trailing slash,
\emph{beng-proxy} refuses to handle the request.


\subsection{Translation server}

The translation server should be the default on production servers.
It is a daemon on the same physical machine which does all the
translation work for us.  \emph{beng-proxy} connects to a Unix socket
to contact this translation server.

A request may consist of several micro commands.  The request is
initialized with the \texttt{BEGIN} command, which is followed by any
number of commands which provide parameters.  After all parameters
have been transferred, the client sends the \texttt{END} command,
and waits for the server's response.

The client can send any number of requests over the socket until one
side closes the connection.

\subsubsection{Example conversation}

\begin{itemize}
\item client sends \texttt{BEGIN}
\item client sends \texttt{REMOTE\_HOST} ``192.168.1.77''
\item client sends \texttt{HOST} ``www.example.com''
\item client sends \texttt{URI} ``/foo/index.html''
\item client sends \texttt{END}
\item server sends \texttt{BEGIN}
\item server sends \texttt{PATH} ``/var/www/foo/index.html''
\item server sends \texttt{CONTENT\_TYPE} ``text/html; charset=utf8''
\item server sends \texttt{PROCESS}
\item server sends \texttt{END}
\end{itemize}

\subsubsection{Command packets}

The protocol is binary and uses host byte order.  A command packet may
look like this in pseudo C:

\begin{verbatim}
struct beng_proxy_translate_packet {
    uint16_t length;
    uint16_t command;
    char payload[length];
};
\end{verbatim}

The \texttt{length} only refers to the payload.  The maximum supported
payload size is 65535 bytes.

Most parameters are ASCII strings; in this case, the payload contains
just the raw string, without terminating zero.

\subsubsection{Request}

\begin{tabular}{|l|p{10cm}|}
\hline
\texttt{REMOTE\_HOST} & the client's IP address or host name \\
\hline
\texttt{HOST} & the \texttt{Host} HTTP request header \\
\hline
\texttt{URI} & the URI from the HTTP request \\
\hline
\texttt{SESSION} & a session identifier generated by the translation
server, see section \ref{sessions} \\
\hline
\texttt{PARAM} & a parameter passed by the browser \\
\hline
\end{tabular}

\subsubsection{Response}

\begin{tabular}{|l|p{10cm}|}
\hline
\texttt{STATUS} & HTTP status code, encoded as \texttt{uint16\_t};
this parameter is usually not used \\
\hline
\texttt{PATH} & absolute path of the local file to be served \\
\hline
\texttt{PATH\_INFO} & optional URI substring which was left after
finding the file \\
\hline
\texttt{SITE} & optional identification or name of the site this
resource belongs to \\
\hline
\texttt{DOCUMENT\_ROOT} & base directory of the site \\
\hline
\texttt{CONTENT\_TYPE} & MIME type of the file (optional) \\
\hline
\texttt{PROXY} & this URL parameter may be specified instead of
\texttt{PATH} to tell \emph{beng-proxy} to obtain the resource from a
remote HTTP server (proxy mode) \\
\hline
\texttt{REDIRECT} & another alternative to \texttt{PATH}: redirect the
HTTP client to this URL; \texttt{STATUS} must be set to one of the
HTTP 3xx codes \\
\hline
\texttt{FILTER} & absolute URL of the filter, see section \ref{filter} \\
\hline
\texttt{PROCESS} & enables the \emph{beng-proxy} processor, see
section \ref{processor} \\
\hline
\texttt{SESSION} & a session identifier generated by the translation
server, see section \ref{sessions} \\
\hline
\texttt{USER} & the user name associated with this session \\
\hline
\texttt{LANGUAGE} & overrides the \texttt{Accept-Language} request
header for this session \\
\hline
\texttt{CGI} & execute the resource as CGI script \\
\hline
\end{tabular}

If the translation server does not provide the \texttt{CONTENT\_TYPE}
header, \emph{beng-proxy} will attempt to discover the file type from
its extended attributes (see \ref{xattr}).

To send a standard error page, the translation server sends a response
containing only the \texttt{STATUS} parameter with the desired HTTP
status.

\subsubsection{Proxying requests}

When proxying HTTP requests with the a \texttt{PROXY} packet,
\emph{beng-proxy} forwards the request to the specified location,
including the HTTP method and the request body.  There is one
exception: if \texttt{PROCESS} is enabled and the original HTTP method
is \texttt{POST}, the other HTTP server receives a \texttt{GET}
request without a body, because the focused widget is going to receive
the request body.

\subsubsection{Filters}
\label{filter}

The translation server can tell \emph{beng-proxy} to apply a filter to
the resource by sending the \texttt{FILTER} command.  This is an
absolute URL which points to a HTTP server.  \emph{beng-proxy} sends
the original resource with a POST request and expects the filtered
resource as response.

If the filter URL starts with a slash, \emph{beng-proxy} assumes it is
the absolute path to a Unix socket.

There may be more than one filter; the order of the \texttt{PROCESS}
and \texttt{FILTER} packets is important.

\subsubsection{Sessions}
\label{sessions}

\emph{beng-proxy} lets the translation server manage a ``session''
variable, which may be empty, or contain a opaque string.  It is up to
the translation server to manage its contents.  With every translation
request, \emph{beng-proxy} sends its contents unless it is empty (in
which case it omits this parameter).  With every response, the
translation server may provide a new value (which may be empty).


\section{Widget protocol}

A widget server is simply an HTTP server.  Its content type must be
text/html.  Alternatively, text/xml is allowed, but the caller must
specify an XSLT file for transformation to HTML.


\subsection{Hyperlinks}

A widget may provide hyperlinks, e.g. with anchor elements or with
FORM elements.

``Internal links'' are links which are relative to the widget's base
URI - these links can be loaded into the widget's dock.  In CGI, this
feature is called ``PATH\_INFO''.  An internal link may include a
query string.

``External URIs'' are not relative, they should
load in a new browser window.

\subsection{Redirection}

Widgets can send the usual HTTP redirection responses (status
\texttt{3xx}).  The new location must be below the widget's base URI.

\emph{beng-proxy} is currently limited to sending a \texttt{GET}
request following the redirect, because it does not save the request
body.  This is always correct for ``303 See Other'', but may not be
for the other redirection types.  Widget servers should therefore
always redirect with ``303 See Other'' as follow-up to a POST request.

\subsection{POSTing}

Making the browser send a request body with a POST request is
possible.  Note however that \emph{beng-proxy} may be very aggressive
about caching POST responses.  To prevent that, you should send a
``303 See Other'' redirect as a response to a POST request.  The same
is valid for every request which modifies a resource - always reckon
that \emph{beng-proxy} may request a resource multiple times, even
without interaction of the browser.

\subsection{Session tracking}

A widget may use HTTP cookies for session tracking, even if the
browser does not support it - \emph{beng-proxy} will take care of it.
The widget should not include some kind of session identification in
the URI.

These cookies are not available in JavaScript.  Besides that, it would
be a bad practice to use cookies in JavaScript which are not actually
evaluated by the server (and cannot be used by the widget server in
this case, since \emph{beng-proxy} does not forward them).  These
cookies would generate a lot of network load for no good, which would
have to go through the visitor's narrow upstream with every request.

\subsection{Authentification}

There is currently no support for HTTP based authentification.

Authentification is supported in the translation protocol.  After the
translation server sets the \texttt{USER} session variable to a
non-empty string, the session is presumed to be authenticated.  This
user variable is passed to widget servers in the proprietary
\texttt{X-CM4all-BENG-User} request header.

XXX further explanation, samples


\subsection{Payment}

It is planned to make \emph{beng-proxy} support pay-per-view widgets
(the webmaster paying to the widget provider).  No further details are
known yet.


\subsection{Referrer}

The \texttt{Referer} request header is not supported.


\section{The Beng Template Language}
\label{processor}

The \emph{Beng} template language defines commands which may be
inserted in the form of XML processing instructions.

\subsection{Adding a widget}

To add a widget, insert the following command:

\begin{verbatim*}
<c:widget id="foo" href="http://cfatest01.intern.cm-ag/date.py" />
\end{verbatim*}

The following attributes may be specified:

\begin{tabular}{|l|p{8cm}|}
\hline
\texttt{id} & unique identification of this widget; this is required
for proper session and form management if there are several widgets
with the same server URI \\
\hline
\texttt{name} & registered name of the widget server \\
\hline
\texttt{href} & use an unregistered widget \\
\hline
\texttt{query\_string} & optional query string to append to the widget
URI (without the question mark) \\
\hline
\texttt{display} & specifies how the widget is to be displayed:
\texttt{inline} is the default, and inserts the widget's HTML code
into the current page; \texttt{iframe} puts the widget into an
\texttt{IFRAME}; \texttt{img} means the widget generates an image, and
it will be referenced from an \texttt{IMG} element \\
\hline
\texttt{session} & the scope of the widget session (which widgets with
the same id share the same session data?): \texttt{resource} is the
default and means that two documents have different sessions;
\texttt{site} means documents in the same site share session data \\
\hline

\texttt{tag} & the SGML tag which decorates widget contents; generate
no decoration if this attribute is empty; ``div'' is default if this
attribute is not specified \\

\hline
\texttt{width}, \texttt{height} & dimensions of the widget \\
\hline
\texttt{style} & inline CSS \\
\hline
\end{tabular}

Registered widgets are not yet implemented.

\subsection{Passing arguments to widgets}

\begin{verbatim*}
<c:widget id="foo" href="http://cfatest01.intern.cm-ag/date.py">
  <param name="timezone" value="PST" />
  <path-info value="/bla" />
</c:widget>
\end{verbatim*}

\texttt{param} elements create query string parameters.  The query
string generated by this is appended to an existing query string
provided by the browser.

There may be one \texttt{path-info} element whose value is appended to
the widget URI.

As usual: never trust user input!  The widget server cannot see if
input came from the template or from the user's browser.

\subsection{Variable substitutions}

\emph{beng-proxy} defines special entities beginning with \texttt{c:}
for its purposes.

\begin{tabular}{|l|p{8cm}|}
\hline
\texttt{\&c:path;} & the location of this widget \\
\hline
\texttt{\&c:prefix;} & XML id and Javascript prefix \\
\hline
\texttt{\&c:uri;} & absolute external URI of the current page; use
this variable for redirecting \\
\hline
\end{tabular}


\section{The Beng JavaScript API}

For convenience, \emph{beng-proxy} provides an optional JavaScript API
for widget authors.  They may use it to inspect and manipulate the
widget.  An example for a common operation is reloading a widget
without reloading the whole page.

\emph{beng-proxy} provides a global variable named
\texttt{rootWidget}, which can be used to obtain pointers to other
widget objects.

The JavaScript widget class provides the following API (pseudo code):

\begin{verbatim*}
class Widget {
  Widget parent;
  Widget getWidget(string path);
  string translateURI(string uri, bool proxy);
  XMLHTTPRequest get(string uri, function onreadystatechange);
  XMLHTTPRequest reload(string uri);
  Element getElement();
}
\end{verbatim*}

To get the current widget object, write the following:

\begin{verbatim*}
var widget = rootWidget.getWidget("&c:path");
\end{verbatim*}

The method \texttt{getElement()} gives you the enclosing element of
the widget (if any).  You may use it to modify the widget's contents.

\texttt{reload()} is a convenience method which sends a HTTP
\texttt{GET} request to the widget server (indirectly via
\emph{beng-proxy}) and replaces the current widget contents with the
response body.  This method is ``F5 safe'', i.e. the new contents will
persist even when the user reloads the whole page (assuming an
idempotent widget server).

If you want more control over this operation, you may use
\texttt{get()} to send a \texttt{GET} request with a custom callback
function, or \texttt{translateURI} to translate a relative widget
server URI to an absolute URL to \emph{beng-proxy}.

The ``uri'' argument is an URI relative to the widget.  It may include
a query string.


\subsection{Contacting the widget server}

Most browsers allow network connections only to the originating web
server, i.e. direct connection to the widget server is not possible.
Plus, it would not preserve session information.

If a widget wants to send an HTTP request to a widget server, it can
use \emph{beng-proxy} as proxy server.  To do that, it passes the
absolute URI to \texttt{Widget.translateURI()} with
\texttt{proxy=true}.  The translated URI should now be used instead of
the original one to perform the HTTP request.

A secure connection (HTTPS) between the browser and the widget server
is not possible.

For proxied request, \emph{beng-proxy} only supports \texttt{GET}
requests without a body and \texttt{POST} requests with a body.


\subsection{Referencing other widgets}

The JavaScript API is currently limited: the JavaScript code of a
widget should only manipulate its own widget objects.  This limitation
will be loosened in a later stage of development.


\end{document}
