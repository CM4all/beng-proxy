\documentclass[a4paper,12pt]{article}
\usepackage[pdftex,bookmarks]{hyperref}

\begin{document}
\title{CM4all Beng}
\author{Max Kellermann}

\maketitle

\begin{abstract}
Beng proxy is an HTTP server including an HTTP proxy and a
minimalistic template processor.  Its goal is to dynamically aggregate
a web site from a number of sources (widgets).
\end{abstract}

\setcounter{tocdepth}{2}
\tableofcontents
\newpage

\section{Features}

Beng-proxy delivers resources via HTTP.  In the most simple form, it
it provides a resource in pass-through mode, acting as an HTTP proxy.

It caches resources if possible.

XML resources can be transformed with XSLT.

On HTML resources, it can apply a simple template language.  This
language provides commands to insert another HTML page, which is
called \textbf{Widget}.

\subsection{Widgets}

A \textbf{Widget} is an object which can be inserted into a web site.
It is rendered by a Widget server into HTML.

We do not assume that we can trust the widget server.  As a
consequence, we have to ensure that a malicious widget server cannot
compromise the security of \emph{beng-proxy}, the client or even other
widget servers.

There is a global registry for well-known preconfigured widgets.  The
user can also choose to run his own (non-registered) widget server.
In fact, any public HTTP server should be able to act as a widget
server.


\subsection{Cookies}

\emph{beng-proxy} can be accessed with cookies switched off.  It includes a
full-featured session management and provides cookies for the widget
servers.

\emph{beng-proxy} maintains the client's session id in either a cookie
or as part of the URI.  In its local session storage, it holds all
cookies which were created by the widget servers.  This way, the
client gets to see only the one session id, disregarding how much
session information may be managed by \emph{beng-proxy}.


\subsection{JavaScript}

Since all widgets are put together into a single HTML page, all of the
JavaScript runs in the same security context.  That will open the door
for malicious widget servers, which are now able to take over the full
web site, including all other widgets.  For that reason, JavaScript is
only allowed for very few well-known and trusted widget servers.  For
all other widget servers, JavaScript use is rejected, or it must be
embedded in an IFRAME, which has technical and practical
disadvantages.


\subsection{Forms}

\emph{beng-proxy} itself does not use the HTTP query string or POST
data.  All of it can be handed off to a widget.  To enable this,
\emph{beng-proxy} rewrites forms, and remembers which widget server to
send the data to.


\section{Translation}

\emph{beng-proxy} knows two ways to locate the resource a request URI
points to:

\begin{itemize}
\item via an external translation server
\item static translation
\end{itemize}

The latter is only for debugging.

\subsection{Static translation}

The URI path is appended to the document root (\texttt{/var/www} by
default).

\subsubsection{Content type}
\label{xattr}

In contrast to most other web servers, \emph{beng-proxy} does not use
the file name to determine the \texttt{Content-Type} response header.
Instead, it reads this information from \textit{extended attributes}.
The programs \texttt{getfattr} and \texttt{setfattr} (Debian package
\texttt{attr}) enable you to read and write attributes:

\begin{verbatim*}
setfattr -n user.Content-Type -v "text/html; charset=utf8" \
/var/www/index.html
\end{verbatim*}

Some file systems need explicit support for extended attributes (mount
option \texttt{user\_xattr}).  On
XFS, extended attributes are always enabled.

\subsubsection{Directory index}

For security (by obscurity) reasons, \emph{beng-proxy} has no code for
generating directory listings.  If the request has a trailing slash,
\emph{beng-proxy} looks for a file named \texttt{index} or
\texttt{index.html} and serves it.  Without the trailing slash,
\emph{beng-proxy} refuses to handle the request.


\subsection{Translation server}

The translation server should be the default on production servers.
It is a daemon on the same physical machine which does all the
translation work for us.  \emph{beng-proxy} connects to a Unix socket
to contact this translation server.

A request may consist of several micro commands.  The request is
initialized with the \texttt{BEGIN} command, which is followed by any
number of commands which provide parameters.  After all parameters
have been transferred, the client sends the \texttt{END} command,
and waits for the server's response.

The client can send any number of requests over the socket until one
side closes the connection.

\subsubsection{Example conversation}

\begin{itemize}
\item client sends \texttt{BEGIN}
\item client sends \texttt{REMOTE\_HOST} ``192.168.1.77''
\item client sends \texttt{HOST} ``www.example.com''
\item client sends \texttt{URI} ``/foo/index.html''
\item client sends \texttt{END}
\item server sends \texttt{BEGIN}
\item server sends \texttt{PATH} ``/var/www/foo/index.html''
\item server sends \texttt{CONTENT\_TYPE} ``text/html; charset=utf8''
\item server sends \texttt{PROCESS}
\item server sends \texttt{END}
\end{itemize}

\subsubsection{Command packets}

The protocol is binary and uses host byte order.  A command packet may
look like this in pseudo C:

\begin{verbatim}
struct beng_proxy_translate_packet {
    uint16_t length;
    uint16_t command;
    char payload[length];
};
\end{verbatim}

The \texttt{length} only refers to the payload.  The maximum supported
payload size is 65535 bytes.

Most parameters are ASCII strings; in this case, the payload contains
just the raw string, without terminating zero.

\subsubsection{Request}

\begin{tabular}{|l|p{10cm}|}
\hline
\texttt{REMOTE\_HOST} & the client's IP address or host name \\
\hline
\texttt{HOST} & the \texttt{Host} HTTP request header \\
\hline
\texttt{URI} & the URI from the HTTP request \\
\hline
\texttt{SESSION} & a session identifier generated by the translation
server, see section \ref{sessions} \\
\hline
\texttt{PARAM} & a parameter passed by the browser \\
\hline
\end{tabular}

\subsubsection{Response}

\begin{tabular}{|l|p{10cm}|}
\hline
\texttt{STATUS} & HTTP status code, encoded as \texttt{uint16\_t};
this parameter is usually not used \\
\hline
\texttt{PATH} & absolute path of the local file to be served \\
\hline
\texttt{PATH\_INFO} & optional URI substring which was left after
finding the file \\
\hline
\texttt{SITE} & optional identification or name of the site this
resource belongs to \\
\hline
\texttt{DOCUMENT\_ROOT} & base directory of the site \\
\hline
\texttt{CONTENT\_TYPE} & MIME type of the file (optional) \\
\hline
\texttt{PROXY} & this URL parameter may be specified instead of
\texttt{PATH} to tell \emph{beng-proxy} to obtain the resource from a
remote HTTP server (proxy mode) \\
\hline
\texttt{REDIRECT} & another alternative to \texttt{PATH}: redirect the
HTTP client to this URL; \texttt{STATUS} must be set to one of the
HTTP 3xx codes \\
\hline
\texttt{FILTER} & absolute URL of the filter, see section \ref{filter} \\
\hline
\texttt{PROCESS} & enables the \emph{beng-proxy} processor, see
section \ref{processor} \\
\hline
\texttt{SESSION} & a session identifier generated by the translation
server, see section \ref{sessions} \\
\hline
\texttt{USER} & the user name associated with this session \\
\hline
\texttt{LANGUAGE} & overrides the \texttt{Accept-Language} request
header for this session \\
\hline

\texttt{CGI} & a local path which is executed as CGI script \\

\hline

\texttt{JAILCGI} & enable JailCGI \\

\hline

\texttt{ADDRESS} & after each packet which provides a host name
(\texttt{PROXY}, \texttt{FILTER}), there must be one or more
\texttt{ADDRESS} packets which specify the resolved addresses.  The
payload of each is a \texttt{struct sockaddr}. \\

\hline
\end{tabular}

If the translation server does not provide the \texttt{CONTENT\_TYPE}
header, \emph{beng-proxy} will attempt to discover the file type from
its extended attributes (see \ref{xattr}).

To send a standard error page, the translation server sends a response
containing only the \texttt{STATUS} parameter with the desired HTTP
status.

\subsubsection{Proxying requests}

When proxying HTTP requests with the a \texttt{PROXY} packet,
\emph{beng-proxy} forwards the request to the specified location,
including the HTTP method and the request body.  There is one
exception: if \texttt{PROCESS} is enabled and the original HTTP method
is \texttt{POST}, the other HTTP server receives a \texttt{GET}
request without a body, because the focused widget is going to receive
the request body.

\subsubsection{Filters}
\label{filter}

The translation server can tell \emph{beng-proxy} to apply a filter to
the resource by sending the \texttt{FILTER} command.  This is an
absolute URL which points to a HTTP server.  \emph{beng-proxy} sends
the original resource with a POST request and expects the filtered
resource as response.

If the filter URL starts with a slash, \emph{beng-proxy} assumes it is
the absolute path to a Unix socket.

There may be more than one filter; the order of the \texttt{PROCESS}
and \texttt{FILTER} packets is important.

\subsubsection{Sessions}
\label{sessions}

\emph{beng-proxy} lets the translation server manage a ``session''
variable, which may be empty, or contain a opaque string.  It is up to
the translation server to manage its contents.  With every translation
request, \emph{beng-proxy} sends its contents unless it is empty (in
which case it omits this parameter).  With every response, the
translation server may provide a new value (which may be empty).

\subsubsection{Widget registry}

The translation server provides access to the widget database, where
all widget servers are registered.  A widget request can use the
following packets:

\begin{tabular}{|l|p{10cm}|}
\hline
\texttt{WIDGET\_TYPE} & the name of the widget type \\
\hline
\end{tabular}

The translation server's response consists of these packets:

\begin{tabular}{|l|p{10cm}|}
\hline
\texttt{STATUS} & in case of a lookup error, this packet provides the
HTTP status code \\
\hline
\texttt{PROXY} & the base HTTP URL of the widget server; may be local
path of a Unix socket \\
\hline
\texttt{PROCESS} & enable the BENG processor \\
\hline
\texttt{CONTAINER} & this widget can contain other widgets \\
\hline

\texttt{GOOGLE\_GADGET} & this is a Google gadget, enable API
emulation \\

\hline
\end{tabular}


\section{Widget protocol}

A widget server is simply an HTTP server.  Its content type must be
text/html.  Alternatively, text/xml is allowed, but the caller must
specify an XSLT file for transformation to HTML.


\subsection{Hyperlinks}

A widget may provide hyperlinks, e.g. with anchor elements or with
FORM elements.

``Internal links'' are links which are relative to the widget's base
URI - these links can be loaded into the widget's dock.  In CGI, this
feature is called ``PATH\_INFO''.  An internal link may include a
query string.

``External URIs'' are not relative, they should
load in a new browser window.

\subsection{Redirection}

Widgets can send the usual HTTP redirection responses (status
\texttt{3xx}).  The new location must be below the widget's base URI.

\emph{beng-proxy} is currently limited to sending a \texttt{GET}
request following the redirect, because it does not save the request
body.  This is always correct for ``303 See Other'', but may not be
for the other redirection types.  Widget servers should therefore
always redirect with ``303 See Other'' as follow-up to a POST request.

\subsection{POSTing}

Making the browser send a request body with a POST request is
possible.  Note however that \emph{beng-proxy} may be very aggressive
about caching POST responses.  To prevent that, you should send a
``303 See Other'' redirect as a response to a POST request.  The same
is valid for every request which modifies a resource - always reckon
that \emph{beng-proxy} may request a resource multiple times, even
without interaction of the browser.

\subsection{Session tracking}

A widget may use HTTP cookies for session tracking, even if the
browser does not support it - \emph{beng-proxy} will take care of it.
The widget should not include some kind of session identification in
the URI.

These cookies are not available in JavaScript.  Besides that, it would
be a bad practice to use cookies in JavaScript which are not actually
evaluated by the server (and cannot be used by the widget server in
this case, since \emph{beng-proxy} does not forward them).  These
cookies would generate a lot of network load for no good, which would
have to go through the visitor's narrow upstream with every request.

\subsection{Authentification}

There is currently no support for HTTP based authentification.

Authentification is supported in the translation protocol.  After the
translation server sets the \texttt{USER} session variable to a
non-empty string, the session is presumed to be authenticated.  This
user variable is passed to widget servers in the proprietary
\texttt{X-CM4all-BENG-User} request header.

XXX further explanation, samples


\subsection{Payment}

It is planned to make \emph{beng-proxy} support pay-per-view widgets
(the webmaster paying to the widget provider).  No further details are
known yet.


\subsection{Referrer}

The \texttt{Referer} request header is not supported.


\section{The Beng Template Language}
\label{processor}

The \emph{beng-proxy} template language defines commands which may be
inserted into XHTML stream.  They are implemented as XML elements and
attributes with the prefix \texttt{c:}.  If you care about validating
the processor input, you must declare the XML namespace \texttt{c:}.
There is currently no suggested namespace URI, and \emph{beng-proxy}
does not actually care, because it does not implement a full-featured
XML parser.

\subsection{Adding a widget}

To add a widget, use the following command:

\begin{verbatim*}
<c:widget id="foo" type="date" />
\end{verbatim*}

The following attributes may be specified:

\begin{tabular}{|l|p{8cm}|}
\hline
\texttt{id} & unique identification of this widget; this is required
for proper session and form management if there are several widgets
with the same server URI \\
\hline
\texttt{type} & registered name of the widget server \\
\hline
\texttt{query\_string} & optional query string to append to the widget
URI (without the question mark) \\
\hline

\texttt{display} & specifies how the widget is to be displayed:
\texttt{inline} is the default, and inserts the widget's HTML code
into the current page; \texttt{none} does not display the widget, but
it may be referenced later (see section \ref{frames}) \\

\hline
\texttt{session} & the scope of the widget session (which widgets with
the same id share the same session data?): \texttt{resource} is the
default and means that two documents have different sessions;
\texttt{site} means documents in the same site share session data \\

\hline
\end{tabular}

Registered widgets are not yet implemented.

\subsection{Passing arguments to widgets}

\begin{verbatim*}
<c:widget id="foo" type="date">
  <param name="timezone" value="PST" />
  <path-info value="/bla" />
</c:widget>
\end{verbatim*}

\texttt{param} elements create query string parameters.  The query
string generated by this is appended to an existing query string
provided by the browser.

There may be one \texttt{path-info} element whose value is appended to
the widget URI.

As usual: never trust user input!  The widget server cannot see if
input came from the template or from the user's browser.

\subsection{Variable substitutions}

\emph{beng-proxy} defines special entities beginning with \texttt{c:}
for its purposes.  Namespaced entities are not actually allowed in XML
or HTML, and this is only an interim solution until the javascript
filter is finished.  These entities are (unlike normal HTML entities)
also expanded in \texttt{SCRIPT} elements.

\begin{tabular}{|l|p{8cm}|}
\hline
\texttt{\&c:path;} & the location of this widget \\
\hline
\texttt{\&c:prefix;} & XML id and Javascript prefix \\
\hline
\texttt{\&c:uri;} & absolute external URI of the current page; use
this variable for redirecting \\
\hline

\texttt{\&c:base;} & base URI of the current page (i.e. without
\emph{beng-proxy} arguments and without the query string) \\

\hline
\texttt{\&c:frame;} & the top widget in this frame (if any) \\
\hline
\texttt{\&c:session;} & the current session id \\
\hline
\end{tabular}

\subsection{Relative URIs}

Relative links are difficult with \emph{beng-proxy}, because the
browser interprets links as relative to the document by default.  A
widget author cannot specify a link relative to the widget itself.  To
allow this, \emph{beng-proxy} can rewrite relative links to the
following bases:

\begin{tabular}{|l|p{10cm}|}
\hline

\texttt{template} & links are relative to the main template (default)
\\

\hline

\texttt{widget} & links are relative to the widget; the browser will
leave \emph{beng-proxy} if the user clicks on such a link, because it
points to the widget server \\

\hline

\texttt{child} & link to a child widget; the URI is the ID of the
child widget \\

\hline
\end{tabular}

The base name must be specified in the element attribute
\texttt{c:base} before the attribute containing the URI.  To specify
the mode of the rewritten URI, you may use the attribute
\texttt{c:mode}:

\begin{tabular}{|l|p{10cm}|}
\hline

\texttt{direct} & direct link to the resource \\

\hline

\texttt{focus} & link to \emph{beng-proxy} serving the full page (or
the current frame), focusing the widget \\

\hline

\texttt{partial} & link to \emph{beng-proxy} serving only the selected
widget; useful for frame contents \\

\hline

\texttt{proxy} & link to \emph{beng-proxy} proxying the selected
resource without further processing \\

\hline
\end{tabular}

The mode is ignored when the base is ``\texttt{template}''.

Example:

\begin{verbatim*}
<img c:base="widget" c:mode="proxy" href="foo.jpg"/>
\end{verbatim*}

\subsection{Frames}
\label{frames}

\emph{beng-proxy} supports displaying widgets in an \texttt{IFRAME} or
\texttt{IMG} element.  To do this, declare your widget with
\texttt{display=none}.  After that, insert an \texttt{IFRAME} element
(or any other element which references its content with an URI), and
let \emph{beng-proxy} rewrite the URI:

\begin{verbatim}
<c:widget id="post" type="demo_post" display="none"/>
<iframe width="200" height="200" c:base="child" c:mode="partial"
  src="post"/>
\end{verbatim}

This may be used for any HTML tag which is supported by the
\emph{beng-proxy} URI rewriting code, here an example for a widget
rendering an image:

\begin{verbatim}
<c:widget id="logo" type="logorenderer" display="none"/>
<img c:base="child" c:mode="proxy" src="logo"
  alt="Our website logo"/>
\end{verbatim}

Note that we use \texttt{c:mode=proxy} here, because an image should
not (and can not) be processed by \emph{beng-proxy}.  You can also use
\texttt{c:mode=direct} if you want the browser to request the resource
from widget server directly instead of proxying through
\emph{beng-proxy}.


\section{The Beng JavaScript API}

JavaScript code in a widget frequently needs to send HTTP requests to
the widget server.  All these requests must got through
\emph{beng-proxy}.  Since the structure of a \emph{beng-proxy} URI is
regarded internal, it provides a JavaScript function to generate such
an URI:

\begin{verbatim*}
function beng_widget_uri(base_uri, session_id, frame, focus, mode, path);
\end{verbatim*}

The return value is the URI which can be safely requested by the
widget server.  For \texttt{base\_uri}, \texttt{session\_id},
\texttt{frame}, you should pass the value of \texttt{\&c:base;},
\texttt{\&c:session;}, \texttt{\&c:frame;}.

\texttt{focus} is the path of the focused widget, and can be filled
with \texttt{\&c:path;} most of the time, unless you can to request a
different widget than the current one.

\texttt{mode} is one of the following:

\begin{tabular}{|l|p{12cm}|}
\hline

\texttt{focus} & the full page (the default if \texttt{null} is
passed) \\

\hline

\texttt{partial} & just this one widget, processor enabled (must be
\texttt{text/html}) \\

\hline
\texttt{proxy} & this widget, but processor disabled, any content type
allowed \\
\hline
\end{tabular}

The \texttt{path} argument is an URI relative to the widget.  It may
include a query string.


\section{The prototype translation server}

Until the \texttt{jetserv} daemon is finished, the prototype
translation server should be used.  It is not configrable; this
section describes its hard-coded behaviour.

\subsection{Request translation}

The document root is \texttt{/var/www}.  File names ending with
\texttt{.html} are mapped to the content type ``text/html;
charset=utf-8'' and are marked with the flags \texttt{PROCESS},
\texttt{CONTAINER}.

\subsection{Widget registry}

The translation server excepts a file for each registered widget type
named \texttt{/etc/cm4all/beng/widgets/TYPENAME}.  Example:

\begin{verbatim*}
server "http://cfatest01.intern.cm-ag/date.py"
process
container
\end{verbatim*}

The first line is mandatory: it specifies the widget server.
\texttt{process} enables the template processor; if that is not
specified, the HTML output is inserted into the resulting page
verbatim.  \texttt{container} allows the widget to embed sub widgets.

Disabling features may increase the performance dramatically, because
it allows \emph{beng-proxy} to make better assumptions on data it does
not know yet.  So if you know the widget is a leaf widget, do not
specify \texttt{container}.

As an alternative to \texttt{process}, you can specify
\texttt{google\_gadget}.  This enables Google gadget emulation.

Instead of \texttt{server}, you can use \texttt{cgi} to specify the
absolute path of a CGI script which will serve the widget, or
\texttt{path} for a static widget.


\end{document}
