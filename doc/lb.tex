\documentclass[a4paper,12pt]{article}
\usepackage[utf8]{luainputenc}
\usepackage{hyperref}
\usepackage{longtable}
\usepackage{tabu}
\tabulinesep=2mm

\begin{document}
\title{CM4all Beng Load Balancer}
\author{Max Kellermann}

\maketitle

\begin{abstract}
\emph{beng-lb} is a light-weight HTTP load balancer.
\end{abstract}

\setcounter{tocdepth}{2}
\tableofcontents
\newpage

\section{Features}

\emph{beng-lb} listens on a number of socket, and forwards the
requests to another server.  Behind one listener socket, more than one
cluster node may be configured.

The algorithm for selecting a cluster node is configurable: it may be
pure load balancing, pure failover, stickiness with the
\emph{beng-proxy} session cookie, or stickiness with a \emph{beng-lb}
cookie.


\section{Installation}

\emph{beng-lb} requires a current Debian operating system.

Install the package \texttt{cm4all-beng-lb}.  Edit the file
\texttt{/etc/cm4all/beng/lb.conf}.  Finally, restart
\emph{beng-lb}:

\begin{verbatim*}
systemctl restart cm4all-beng-lb
\end{verbatim*}

\section{Configuration}

Configuration is read from the file
\texttt{/etc/cm4all/beng/lb.conf}.  From there, other files can be
included with the \texttt{@include} keyword:

\begin{verbatim*}
@include "foo/bar.conf"
@include_optional "foo/may-not-exist.conf"
\end{verbatim*}

The second line silently ignores non-existing files.

The following object types can be configured here:

\begin{itemize}
\item nodes
\item pools
\item listeners
\end{itemize}

\subsection{Variables (\texttt{@set})}

Set a variable.  Within double-quoted strings, variables can be
expanded with \verb|${name}|.  Example:

\begin{verbatim*}
@set foo = "192.168.1.42"
@set bar = "${foo}:80"
listener {
  bind "${bar}"
}
\end{verbatim*}

At the time of this writing, the concept of variables is not
well-implemented.  For example, (backslash) escape sequences don't
work, and the scope of variables is not defined.  For now, use
variables only for very simple things.

\subsection{Nodes}

A ``node'' is one server in a cluster.  It handles requests.  The node
has an IP address, but no port/service.  A node can have multiple
services, it can be member in multiple pools.  Technically, a physical
server can have multiple nodes by having more than one IP address, but
that is only a side effect and is not useful in practice.

Example:

\begin{verbatim*}
node localhost {
  address "127.0.0.1"
}
\end{verbatim*}

\subsection{Pools}

A pool is a cluster of nodes for a specific service.  When a request
needs to be handled, the pool chooses a member and sends the request
to this node.  Upon failure, it may repeat the request with a
different node.

Example:

\begin{verbatim*}
pool demo {
  protocol "http"
  member "foo:http"
  member "bar:http"
}
\end{verbatim*}

Instead of referring to a previously defined node name, you can
configure an IP address instead, and \texttt{beng-lb} creates a new
node implicitly.

The \verb|sticky| setting specifies how a node is chosen for a
request, see \ref{sticky} for details.

When all pool members fail, an error message is generated.  You can
override that behaviour by configuring a ``fallback'':

\begin{verbatim*}
pool demo {
  fallback "http://the.fallback.server/error.html"
  # ...
}
\end{verbatim*}

This would generate a ``320 Found'' redirect to the specified URL.
Another type of fallback is a custom response, you can specify a HTTP
status code and a brief message (plain text):

\begin{verbatim*}
pool demo {
  fallback "500" "Currently not available."
  # ...
}
\end{verbatim*}

The option \texttt{mangle\_via yes} enables request header mangling:
the headers \texttt{Via} and \texttt{X-Forwarded-For} are updated.

\subsubsection{Zeroconf}

To discover pool members automatically using Zeroconf, use the
\verb|zeroconf_service| setting:

\begin{verbatim*}
pool "auto" {
   zeroconf_service "widgetserver"
}
\end{verbatim*}

It will look up in the default domain; to use another domain, use the
\verb|zeroconf_domain| setting.

This requires \texttt{avahi-daemon} to be installed and running.  And,
of course, it requires the pool members to publish their service.

If ``sticky'' is enabled on the pool, then \emph{beng-lb} uses
\href{https://en.wikipedia.org/wiki/Consistent_hashing}{consistent
  hashing} to pick a member (to reduce member reassignments).

With option \verb|sticky_cache| set to \verb|yes|, consistent hashing
is disabled in favor of an assignment cache.  The advantage of that
cache is that existing clients will not be reassigned when new nodes
appear.  The major disadvantage is that this works only with a single
\emph{beng-lb} instance, and the cache is lost on restart.  The
default is \verb|no|.

\subsubsection{Protocols}

The protocol \texttt{tcp} forwards raw a raw bidirectional TCP stream.
It is the fastest mode, and should be used when no special protocol
parsing is needed.

The protocol \texttt{http} means that \texttt{beng-lb} parses the
HTTP/1.1 request/response, and forwards them to the peer.  This HTTP
parser is needed for some of the advanced features, such as cookies.

\subsection{Transparent Source IP}

The \verb|source_address| setting can be used on TCP pools to forward
the connection transparently with its original source IP.  Example
configuration:

\begin{verbatim*}
pool demo {
  protocol "tcp"
  source_address "transparent"
  member "foo:1234"
  member "bar:1234"
}
\end{verbatim*}

Note that this requires a routing table on the pool members that
routes reply packets back to \emph{beng-lb} instead of replying to the
client directly.  The easiest way to do it is make the \emph{beng-lb}
server the default gateway.  If that is not desirable, advanced
routing with Netfilter marks are a powerful alternative.

\subsection{Conditional Pools}

Incoming requests can be delivered to pools based on
administrator-specified conditions.  This virtual pool is called
``branch'', and can be referenced by its name just like regular pools.
That implies that pools and branches share a namespace, their names
must be uniquie.  Example:

\begin{verbatim*}
branch foo {
  goto pool1 if $request_method == "POST"
  goto pool2 if $request_uri =~ "^/for/pool2/"
  goto pool3 if $http_user_agent =~ "Opera"
  goto pool4
}
\end{verbatim*}

The object contains any number of ``goto'' statements, all but the
last one with conditions.  These ``goto'' statements can refer to a
pool or another branch.

The following ``variables'' are available:

\begin{longtabu*}{|l|X|}
\hline
\verb|$request_method| & the HTTP request method (``\texttt{GET}'',
``\texttt{POST}'', ...) \\
\hline
\verb|$request_uri| & the HTTP request URI \\
\hline
\verb|$http_header_name| & a HTTP request header with the
specified name, lower case, dashes converted to underscore \\
\hline
\end{longtabu*}

The following operators are available:

\begin{longtabu*}{|l|X|}
\hline
\verb|==| & check the value for equality \\
\hline
\verb|!=| & check the value for non-equality \\
\hline
\verb|=~| & Perl-compatible regular expression match \\
\hline
\verb|!~| & Perl-compatible regular expression mismatch \\
\hline
\end{longtabu*}

The last token is a quoted string decpiting the value to compare with,
or the regular expression.

Instead of \verb|goto|, you can use \verb|status| or \verb|redirect|
to let \emph{beng-lb} generate a brief response with the given HTTP
status code or \verb|Location| header:

\begin{verbatim*}
branch foo {
  status 418 if $http_user_agent =~ "BadBot"
  redirect "http://www.cm4all.com/" if $http_user_agent =~ "Foo"
  goto bar
}
\end{verbatim*}

At the time of this writing, conditional pools work only for HTTP, not
for TCP.

\subsection{Lua Request Handlers}

HTTP requests can be handled by Lua scripts.  The \verb|lua_handler|
section declares such a request handler:

\begin{verbatim*}
lua_handler "my_lua_handler" {
  path "test.lua"
  function "handle_request"
}
\end{verbatim*}

The name \verb|my_lua_handler| can be referred to by a
\verb|listener|'s \verb|pool| setting.

A simple Lua script may look like this:

\begin{verbatim*}
function handle_request(r)
   r:send_message("Hello world")
end
\end{verbatim*}

The configured function receives one parameter: the request object.
The following attributes are available:

\begin{longtabu*}{|l|X|}
\hline
\verb|uri| & the request URI \\
\hline
\verb|method| & the request method \\
\hline
\verb|has_body| & \verb|true| if a request body is present \\
\hline
\verb|remote_host| & the client's IP address \\
\hline
\end{longtabu*}

Read-only methods:

\begin{longtabu*}{|l|X|}
\hline

\verb|get_header|(\verb|name|) & Look up a request header.  For
performance reasons, the name must be lower-case. \\

\hline
\end{longtabu*}

The following methods can be used to generate a response:

\begin{longtabu*}{|l|X|}
\hline

\verb|send_message|(\verb|msg|) & Send a plain-text response. \\

\hline

\verb|send_message|(\verb|status|, \verb|msg|) & Send a plain-text
response with the given status.\\

\hline
\end{longtabu*}

To forward the HTTP request to a configured pool, the Lua script
should look up that pool in the \verb|pools| table (which is, for
performance reasons, only available during global initialization), and
then return that pool from the handler function, e.g.:

\begin{verbatim*}
foo = pools['foo']
function handle_request(r)
   return foo
end
\end{verbatim*}

The \verb|pools| table contains all configured \verb|pool|,
\verb|branch| and \verb|lua_handler| sections.  This means that Lua
code can direct the HTTP request into a \verb|branch| or into another
Lua script.  Be careful to avoid loops!

Caution: while a Lua script runs, the whole \emph{beng-lb} process is
blocked.  It is very easy to make \emph{beng-lb} unusable with a Lua
script.  Each Lua invocation adds big amounts of overhead.  This
feature is only meant for development and quick'n'dirty hacks.  Don't
use in production, and if you really must do, take extreme care to
make the Lua code finish quickly.

\subsection{Translation Request Handlers}

This handler asks a translation server which pool shall be used to
handle a HTTP request.  The \verb|translation_handler| section
declares such a request handler:

\begin{verbatim*}
translation_handler "my_translation_handler" {
  connect "@translation"
  pools "a" "b" "c"
}
\end{verbatim*}

The \verb|pools| line specifies the pools (or branches or Lua handlers
...) which may be chosen from.

Details about the wire protocol between \emph{beng-lb} and the
translation server can be found in the \emph{beng-proxy}
documentation.

\subsection{Listener}

A listener is a socket address (IP and port) which accepts incoming
TCP connections.

\begin{verbatim*}
listener port80 {
  bind "*:80"
  tag "foo"
  pool "demo"
}
\end{verbatim*}

A listener has a name, a socket address to bind to (including the
port).  To handle requests, it is associated with exactly one pool.

Known attributes:

\begin{longtabu*}{|l|X|}\hline

\verb|tag| & An optional tag, to be passed to the translation server
in a \verb|LISTENER_TAG| packet (if a translation server is ever
queried during a HTTP request). \\\hline

\verb|bind| & An adddress to bind to.  May be the wildcard ``*'' or an
IPv4/IPv6 address followed by a port.  IPv6 addresses should be
enclosed in square brackets to disambiguate the port separator.  Local
sockets start with a slash ``/'', and abstract sockets start with an
at symbol ``@''. \\\hline

\verb|interface| & Limit this listener to the given network
interface. \\\hline

\verb|reuse_port| & \texttt{yes} enables the socket option
\verb|SO_REUSEPORT|, which allows multiple sockets to bind to the same
port. \\\hline

\verb|free_bind| & \texttt{yes} enables the socket option
\verb|IP_FREEBIND|, which allows binding to an address which does not
yet exist.  This is useful when the daemon shall be started before all
network interfaces are up and configured. \\\hline

\verb|ssl| & \texttt{yes} enables SSL/TLS.  See \ref{ssl} for more
information and more SSL options. \\\hline

\verb|verbose_response| & \texttt{yes} exposes internal error messages
in HTTP responses. \\\hline

\end{longtabu*}

\subsection{Sticky}
\label{sticky}

A pool's \verb|sticky| setting specifies how a node is chosen for a
request.  Example:

\begin{verbatim*}
pool demo {
  protocol "http"
  member "foo:http"
  member "bar:http"
  sticky "failover"
}
\end{verbatim*}

Requests to this pool are always sent to the node named ``foo''.  The
second node ``bar'' is only used when ``foo'' fails.

Other sticky modes:

\begin{itemize}
\item \texttt{none}: simple round-robin (the default mode)
\item \texttt{failover}: the first non-failing node is used
\item \verb|source_ip|: the modulo of the client's source IP is used
  to calculate the node
\item \verb|host|: the hash of the \texttt{Host} request header (or
  the \verb|CANONICAL_HOST| translation packet) is used to calculate
  the node
\item \verb|xhost|: the hash of the \texttt{X-CM4all-Host} request
  header is used to calculate the node
\item \texttt{session\_modulo}: the modulo of the \texttt{beng-proxy}
  session is used to calculate the node
\item \texttt{cookie}: a random cookie is generated, and the node is
  chosen from the cookie that is received from the client
\item \verb|jvm_route|: Tomcat's JSESSIONID is parsed, and its suffix
  is compared against the \verb|jvm_route| of all member nodes
\end{itemize}

\subsubsection{Tomcat}

For the \verb|jvm_route| mode, both \emph{beng-lb} and Tomcat must be
configured properly.  Example \texttt{lb.conf}:

\begin{verbatim*}
node first {
   address 192.168.1.101
   jvm_route jvm1
}

node second {
   address 192.168.1.102
   jvm_route jvm2
}

pool demo {
  protocol "http"
  member "second:http"
  member "second:http"
  sticky "jvm_route"
}
\end{verbatim*}

Example \texttt{server.xml} on the ``first'' Tomcat:

\begin{verbatim*}
<Engine name="Catalina" defaultHost="localhost" jvmRoute="jvm1">
\end{verbatim*}

The \verb|jvmRoute| settings must match in \emph{beng-lb} and Tomcat.
It is allowed to set \verb|jvm_route| in a node that is used in pools
without the according \verb|sticky| setting.

\subsection{SSL/TLS}
\label{ssl}

To enable SSL/TLS on a listener, configure:

\begin{verbatim*}
listener ssl {
  bind "*:443"
  pool "demo"
  ssl "yes"
  ssl_cert "/etc/cm4all/beng/lb/cert.pem" "/etc/cm4all/beng/lb/key.pem"
}
\end{verbatim*}

One pool can be shared by listeners with and without SSL.

\subsubsection{Server Name Indication}

You can specify multiple \verb|ssl_cert| lines.  All certificate/key
pairs are loaded.  During the TLS handshake, the client may announce
the desired server name with the TLS extension ``SNI'' (Server Name
Indication).  \emph{beng-lb} uses this name to choose a certificate.
Currently, it uses the first matching certificate, but that algorithm
may be changed in the future to ``most specific certificate''.  If no
certificate matches, the first certificate is used.

\subsubsection{Certificate Database}
\label{certdbconfig}

Instead of configuring each server certificate in the configuration
file, you can store certificate/key pairs in a PostgreSQL database.
The \texttt{listener} option \verb|ssl_cert_db| specifies the symbolic
name of a \verb|cert_db| section:

\begin{verbatim*}
cert_db foo {
  connect "dbname=lb"
  ca_cert "/etc/cm4all/beng/lb/ca1.pem"
  ca_cert "/etc/cm4all/beng/lb/ca2.pem"
  # ...
  wrap_key "foo" "0123456789abcdef..."
  # ...
}

listener ssl {
  bind "*:443"
  pool "demo"
  ssl "yes"
  ssl_cert "/etc/cm4all/beng/lb/cert.pem" "/etc/cm4all/beng/lb/key.pem"
  ssl_cert_db "foo"
}
\end{verbatim*}

There must be at least one regular \verb|ssl_cert|.

The \verb|cert_db| section may contain any number of \verb|ca_cert|
lines, each specifying a CA certificate chain file in PEM format.
Each certificate loaded from the database will be accompanied with the
chain, if a matching one was found.

The \verb|connect| setting contains a PostgreSQL connect string.
Optionally, you may specify a non-standard PostgreSQL schema with the
\verb|schema| setting.  Note that you need to allow the configured
PostgreSQL user to access the schema using \texttt{GRANT USAGE ON
  SCHEMA TO username}.

If at least one \verb|wrap_key| setting is present, all new private
keys will be encrypted (``wrapped'') with the first AES256 key.  That
way, private keys are not leaked to everybody with read acccess to the
database.  Multiple \verb|wrap_key| lines may be used to migrate to
new AES keys, while still being able to use private keys encrypted
with an old AES key.  The database refers to AES keys by their name,
which means you must not rename the keys in the configuration file.  A
new AES key may be generated using ``\verb|cm4all-certdb genwrap|''.

Each time a server name is received from a client, \emph{beng-lb} will
attempt to look up a matching certificate, and use that for the TLS
handshake.

See \ref{certdb} for instructions on how to create and manage the
database.

\subsubsection{Client Certificates}

The option \verb|ssl_verify| enables client certificates.  A
connection without a client certificate will be rejected.  The client
certificate will only be accepted if its issuer can be validated by
the server.  By default, the CA certificates in \verb|/etc/ssl/certs/|
are used for this.  You can specify a custom CA file with the option
\verb|ssl_ca_cert|, which refers to a PEM file containing one or more
concatenated acceptable CA certificates.  Example:

\begin{verbatim*}
listener ssl {
  bind "*:443"
  pool "demo"
  ssl "yes"
  ssl_cert "/etc/cm4all/beng/lb/cert.pem" "/etc/cm4all/beng/lb/key.pem"
  ssl_verify "yes"
  ssl_ca_cert "/etc/cm4all/beng/lb/ca.pem"
}
\end{verbatim*}

The subject of the client certificate is copied to the web server in
the \verb|X-CM4all-BENG-Peer-Subject| request header, and its issuer
uses the \verb|X-CM4all-BENG-Peer-Issuer-Subject| request header.

By setting \verb|ssl_verify| to ``optional'', the connection will not
be rejected if the client chooses not to send a certificate, and the
headers described above will not be present.  A client using an
untrusted certificate will still be rejected.

Note that due to technical limitations of the current implementation,
it is not possible to combine client certificate and the certificate
database.

\subsection{Monitors}

A ``monitor'' describes how the availability of nodes in a pool is
checked periodically.  By default, there is no monitor, just a list of
``known-bad'' nodes, filled with failures.

The option ``interval'' configures how often the monitor is executed
(in seconds).

The option ``timeout'' specifies how long \emph{beng-lb} waits for a
response (in seconds).

\subsection{Check}

The section \verb|global_http_check| can be used to intercept a
certain host/URI combination for monitors of load balancers in front
of \emph{beng-lb}:

\begin{verbatim*}
global_http_check {
  uri "/aLiVeChEcK.sErViCe"
  host "localhost"
  client "192.168.1.0/24"
  client "2003:abcd::/32"
  file_exists "/run/cm4all/beng-lb.alive"
  success_message "webisonline"
}
\end{verbatim*}

All requests on all HTTP listeners matching the given URI and Host
request header will divert into a special handler which checks the
existence of the given file.  If it exists, then the configured
message is emitted.  If not, then an error is emitted.

The \verb|client| setting is optional.  If at least one is given, then
only the specified client addresses / networks are diverted to this
handler.

\subsubsection{Ping}

The ``ping'' monitor periodically sends echo-request ICMP packets to
the node, and excepts echo-reply ICMP packets.

\begin{verbatim*}
monitor "my_monitor" {
  type "ping"
  interval "2"
}

pool "demo" {
  member "...
  monitor "my_monitor"
}
\end{verbatim*}

This requires Linux kernel 3.0 or newer.  \emph{beng-lb} must be
allowed to use the ICMP socket, which can be configured in the virtual
file:

\texttt{/proc/sys/net/ipv4/ping\_group\_range}

\subsubsection{Connect}

The ``connect'' monitor attempts to establish a TCP connection, and
closes it immediately.

\subsubsection{TCP Expect}

The ``tcp\_expect'' monitor opens a TCP connection, optionally sends
some data, and expects a certain string in the response.

\begin{verbatim*}
monitor "expect_monitor" {
  type "tcp_expect"
  send "GET / HTTP/1.1\r\nHost: localhost\r\n\r\n"
  expect "HTTP/1.1 200 OK"
}
\end{verbatim*}

The \texttt{send} setting is optional.

The \verb|expect_graceful| setting can be used for graceful shutdown:

\begin{verbatim*}
monitor "expect_monitor2" {
  type "tcp_expect"
  send "GET / HTTP/1.1\r\nHost: localhost\r\n\r\n"
  expect "HTTP/1.1 200 OK"
  expect_graceful "HTTP/1.1 503 Service Unavailable"
}
\end{verbatim*}

If the configured string is received, the node will only receive
``sticky'' requests, but no new sessions.

In addition to the generic total \verb|timeout| setting, the setting
\verb|connect_timeout| can be used to limit the time for the TCP
connect.


\subsection{\texttt{control}}
\label{config.control}

Listen for control commands the configured address.  Example:

\begin{verbatim*}
control {
  bind "@beng-lb"
}
\end{verbatim*}

This binds to the abstract address \verb|beng-lb|.

Known attributes:

\begin{longtabu*}{|l|X|}\hline

\verb|bind| & An adddress to bind to.  May be the wildcard ``*'' or an
IPv4/IPv6 address followed by a port.  IPv6 addresses should be
enclosed in square brackets to disambiguate the port separator.  Local
sockets start with a slash ``/'', and abstract sockets start with an
at symbol ``@''. \\\hline

\verb|multicast_group| & Join this multicast group, which allows
receiving multicast commands.  Value is a multicast IPv4/IPv6
address.  IPv6 addresses may contain a scope identifier after a
percent sign ('\%'). \\\hline

\verb|interface| & Limit this listener to the given network
interface. \\\hline

\end{longtabu*}


\subsection{Access Loggers}

The configuration block \verb|access_logger| configures the access
logger.  The \emph{beng-proxy} manual has more information about this.


\section{Certificate Database}
\label{certdb}

The certificate database is useful for bulk hosting.  The database may
contain a dynamic list of X.509 server certificates.

See \ref{certdbconfig} for instructions on how to configure the
database in \emph{beng-lb}.

\subsection{Creating the Database}

Create a PostgreSQL database and run the file \texttt{certdb.sql} to
create the table.

\subsection{Migrating the Database}

To update the database schema after an update, type:

\begin{verbatim*}
cm4all-certdb migrate
\end{verbatim*}

After the schema update, all users of the database should be updated
quickly to the same version.  While it is attempted to keep read-only
backwards compatibility as much as possible, applications with write
access may cease to work after the migration.

\subsection{Managing Certificates}

The program \texttt{cm4all-certdb} is a frontend for the database.  It
loads the PostgreSQL connect string and the \verb|wrap_key| settings
from the \emph{beng-lb} configuration file
(i.e. \texttt{/etc/cm4all/beng/lb.conf}).  The connect string can be
overridden from the one-line text file
\texttt{/etc/cm4all/beng/certdb.connect}, just in case this
command-line tool needs a different setting.

Load a new certificate into the database:

\begin{verbatim*}
cm4all-certdb load cert.pem key.pem
\end{verbatim*}

Find a certificate for the given name:

\begin{verbatim*}
cm4all-certdb find www.example.com
\end{verbatim*}

Monitor database changes:

\begin{verbatim*}
cm4all-certdb monitor
\end{verbatim*}

\subsection{Let's Encrypt}

The \texttt{cm4all-certdb} program includes an ACME (Automatic
Certificate Management Environment) client, the protocol implemented
by the \emph{Let's Encrypt} project.

To get started, register an account:

\begin{verbatim*}
openssl genrsa -out /etc/cm4all/acme/account.key  4096
cm4all-certdb acme --staging new-reg foo@example.com
\end{verbatim*}

\small{Note: examples listed here will use the ``staging'' server.
  Omit the \texttt{--staging} option to use the \emph{Let's Encrypt}
  production server.}

To obtain a signed certificate, type:

\begin{verbatim*}
cm4all-certdb acme --staging new-authz-cert example www.example.com
\end{verbatim*}

To update all names in an existing certificate, use the command
\texttt{renew-cert} and specify only the handle (``\texttt{example}''
here):

\begin{verbatim*}
cm4all-certdb acme --staging renew-cert example
\end{verbatim*}

This requires that \emph{beng-lb} runs on the same machine and can be
contacted at \texttt{www.example.com} port 443, with the certificate
database enabled on that listener.

The command \texttt{new-authz-cert} creates a new \texttt{authz}
object for the specified host name, asks the ACME server to conduct
TLS-SNI-01 validation (by connecting to \emph{beng-lb}, which will use
a specially crafted self-signed certificate).  After the validation
succeeds, it will create a new private key and a certificate signing
request, and ask the ACME server to sign the new certificate.

After the program finishes, the new certificate should be usable
immediately.

\end{document}
